name: Test IP Connectivity and Create Release

on:
  schedule:
    - cron: '0 19 * * *'  # æ¯å¤©åŒ—äº¬æ—¶é—´å‡Œæ™¨3ç‚¹è¿è¡Œ (UTC 19:00 = åŒ—äº¬æ—¶é—´ 03:00)
  workflow_dispatch:  # å…è®¸æ‰‹åŠ¨è§¦å‘
  push:
    branches:
      - main
    paths:
      - '.github/workflows/ip-test.yml'
      - 'api.txt'

# æ·»åŠ å¿…è¦çš„æƒé™
permissions:
  contents: write  # å…è®¸åˆ›å»º Release å’Œä¸Šä¼ æ–‡ä»¶
  actions: read

jobs:
  test-and-release:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        pip install requests aiohttp asyncio dnspython beautifulsoup4 lxml

    - name: Verify api.txt exists
      run: |
        if [ ! -f api.txt ]; then
          echo "âŒ api.txt æ–‡ä»¶ä¸å­˜åœ¨ï¼Œæ­£åœ¨åˆ›å»ºç¤ºä¾‹æ–‡ä»¶..."
          cat > api.txt << 'APIEOF'
        # API åˆ—è¡¨é…ç½®æ–‡ä»¶
        # æ¯è¡Œä¸€ä¸ª API åœ°å€ï¼Œ# å¼€å¤´çš„è¡Œä¸ºæ³¨é‡Š
        # 
        # CloudFlare IP ä¼˜é€‰ API
        https://raw.githubusercontent.com/ymyuuu/IPDB/refs/heads/main/bestproxy.txt
        https://raw.githubusercontent.com/ymyuuu/IPDB/refs/heads/main/bestcf.txt
        https://ip.164746.xyz/ipTop10.html
        https://raw.githubusercontent.com/ZhiXuanWang/cf-speed-dns/refs/heads/main/ipTop10.html
        https://vps789.com/public/sum/cfIpApi
        # https://www.wetest.vip/api/cf2dns/get_cloudflare_ip&type=v4&key=o1zrmHAF
        https://raw.githubusercontent.com/cmliu/WorkerVless2sub/main/addressesapi.txt
        https://addressesapi.090227.xyz/CloudFlareYes
        https://addressesapi.090227.xyz/ip.164746.xyz
        APIEOF
          echo "âœ… å·²åˆ›å»ºç¤ºä¾‹ api.txt æ–‡ä»¶"
        fi
        echo "ğŸ“‹ API åˆ—è¡¨å†…å®¹ï¼š"
        cat api.txt

    - name: Create test script
      run: |
        cat > test_ip.py << 'EOF'
        import asyncio
        import aiohttp
        import json
        import re
        import socket
        from datetime import datetime
        from typing import List, Dict, Optional, Tuple
        import time
        import os
        import dns.resolver

        # æ¯ä¸ªåœ°åŒºä¿ç•™çš„æœ€å¤§IPæ•°é‡
        MAX_IPS_PER_LOCATION = 5

        # ä¸­å›½ä¸‰å¤§è¿è¥å•†çš„å…¬å…± DNS æœåŠ¡å™¨
        ISP_DNS = {
            'ç”µä¿¡': ['114.114.114.114', '114.114.115.115'],
            'è”é€š': ['123.123.123.123', '123.125.81.6'],
            'ç§»åŠ¨': ['221.179.155.161', '112.4.0.55']
        }

        # å›½å®¶ä»£ç æ˜ å°„
        COUNTRY_MAPPING = {
            'CN': 'ä¸­å›½', 'HK': 'é¦™æ¸¯', 'TW': 'å°æ¹¾', 'JP': 'æ—¥æœ¬', 'KR': 'éŸ©å›½',
            'SG': 'æ–°åŠ å¡', 'MY': 'é©¬æ¥è¥¿äºš', 'TH': 'æ³°å›½', 'VN': 'è¶Šå—', 'ID': 'å°å°¼',
            'IN': 'å°åº¦', 'PH': 'è²å¾‹å®¾', 'US': 'ç¾å›½', 'CA': 'åŠ æ‹¿å¤§', 'MX': 'å¢¨è¥¿å“¥',
            'DE': 'å¾·å›½', 'GB': 'è‹±å›½', 'FR': 'æ³•å›½', 'IT': 'æ„å¤§åˆ©', 'ES': 'è¥¿ç­ç‰™',
            'PT': 'è‘¡è„ç‰™', 'NL': 'è·å…°', 'BE': 'æ¯”åˆ©æ—¶', 'SE': 'ç‘å…¸', 'NO': 'æŒªå¨',
            'AU': 'æ¾³å¤§åˆ©äºš', 'NZ': 'æ–°è¥¿å…°', 'BR': 'å·´è¥¿', 'AR': 'é˜¿æ ¹å»·', 'RU': 'ä¿„ç½—æ–¯',
            'CH': 'ç‘å£«', 'AT': 'å¥¥åœ°åˆ©', 'DK': 'ä¸¹éº¦', 'FI': 'èŠ¬å…°', 'IE': 'çˆ±å°”å…°',
            'PL': 'æ³¢å…°', 'CZ': 'æ·å…‹', 'TR': 'åœŸè€³å…¶', 'AE': 'é˜¿è”é…‹', 'IL': 'ä»¥è‰²åˆ—',
            'ZA': 'å—é', 'EG': 'åŸƒåŠ', 'SA': 'æ²™ç‰¹', 'UA': 'ä¹Œå…‹å…°', 'GR': 'å¸Œè…Š'
        }

        def load_api_list(filename: str = 'api.txt') -> List[str]:
            """ä» api.txt åŠ è½½ API åˆ—è¡¨"""
            api_urls = []
            
            if not os.path.exists(filename):
                print(f"âŒ {filename} æ–‡ä»¶ä¸å­˜åœ¨")
                return api_urls
            
            with open(filename, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    # å¿½ç•¥ç©ºè¡Œå’Œ # å¼€å¤´çš„æ³¨é‡Šè¡Œ
                    if line and not line.startswith('#'):
                        api_urls.append(line)
            
            print(f"âœ… ä» {filename} åŠ è½½äº† {len(api_urls)} ä¸ª API")
            return api_urls

        def is_valid_ip(ip: str) -> bool:
            """éªŒè¯IPåœ°å€æ ¼å¼"""
            parts = ip.split('.')
            if len(parts) != 4:
                return False
            for part in parts:
                try:
                    num = int(part)
                    if num < 0 or num > 255:
                        return False
                    if len(part) > 1 and part[0] == '0':
                        return False
                except ValueError:
                    return False
            return True

        def is_valid_port(port: str) -> bool:
            """éªŒè¯ç«¯å£å·æ ¼å¼"""
            try:
                num = int(port)
                return 0 < num <= 65535
            except ValueError:
                return False

        def parse_ip_line(line: str) -> Optional[Dict]:
            """è§£æIPè¡Œï¼Œæ”¯æŒå¤šç§æ ¼å¼"""
            line = line.strip()
            
            # è·³è¿‡æ— æ•ˆè¡Œ
            if not line or line.startswith(('#', '//', '<!--', 'http')):
                return None
            
            # æ¨¡å¼1: IP:Port#Country
            match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)#(.+)$', line)
            if match:
                ip, port, country = match.groups()
                if is_valid_ip(ip) and is_valid_port(port):
                    return {'ip': ip, 'port': port, 'country': country.strip()}
            
            # æ¨¡å¼2: IP#Country
            match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})#(.+)$', line)
            if match:
                ip, country = match.groups()
                if is_valid_ip(ip):
                    return {'ip': ip, 'port': '443', 'country': country.strip()}
            
            # æ¨¡å¼3: IP:Port
            match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)', line)
            if match:
                ip, port = match.groups()
                if is_valid_ip(ip) and is_valid_port(port):
                    return {'ip': ip, 'port': port, 'country': None}
            
            # æ¨¡å¼4: å•ç‹¬IP
            match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})$', line)
            if match:
                ip = match.group(1)
                if is_valid_ip(ip):
                    return {'ip': ip, 'port': '443', 'country': None}
            
            return None

        async def fetch_url(session: aiohttp.ClientSession, url: str) -> str:
            """å¼‚æ­¥è·å–URLå†…å®¹"""
            try:
                async with session.get(url, timeout=aiohttp.ClientTimeout(total=30)) as response:
                    if response.status == 200:
                        return await response.text()
                    else:
                        print(f"âš ï¸  {url} è¿”å›çŠ¶æ€ç : {response.status}")
            except asyncio.TimeoutError:
                print(f"â±ï¸  {url} è¯·æ±‚è¶…æ—¶")
            except Exception as e:
                print(f"âŒ è·å– {url} å¤±è´¥: {e}")
            return ""

        def normalize_location(location: str) -> str:
            """æ ‡å‡†åŒ–åœ°ç†ä½ç½®æ ¼å¼"""
            if not location or location == 'Unknown':
                return 'Unknown'
            
            # ç§»é™¤å¤šä½™ç©ºæ ¼å’Œç‰¹æ®Šå­—ç¬¦
            location = location.strip()
            location = re.sub(r'\s+', ' ', location)
            
            # å¦‚æœæ²¡æœ‰åˆ†éš”ç¬¦ï¼Œå°è¯•æ·»åŠ 
            if '-' not in location and ' ' in location:
                parts = location.split(' ', 1)
                location = '-'.join(parts)
            
            return location

        async def get_ip_location(session: aiohttp.ClientSession, ip: str, retry: int = 2) -> str:
            """è·å–IPè¯¦ç»†åœ°ç†ä½ç½®ï¼ˆå›½å®¶+åœ°åŒº/åŸå¸‚ï¼‰ï¼Œå¸¦é‡è¯•æœºåˆ¶"""
            
            # æ–¹æ³•1: ä½¿ç”¨ ip-api.com (ä¸­æ–‡æ”¯æŒæ›´å¥½)
            for attempt in range(retry):
                try:
                    async with session.get(f'http://ip-api.com/json/{ip}?lang=zh-CN&fields=status,country,regionName,city,countryCode', 
                                          timeout=aiohttp.ClientTimeout(total=10)) as response:
                        if response.status == 200:
                            data = await response.json()
                            if data.get('status') == 'success':
                                country = data.get('country', '')
                                region_name = data.get('regionName', '')
                                city = data.get('city', '')
                                country_code = data.get('countryCode', '')
                                
                                # å¦‚æœæ˜¯è‹±æ–‡å›½å®¶åï¼Œå°è¯•è½¬æ¢ä¸ºä¸­æ–‡
                                if country_code and country_code in COUNTRY_MAPPING:
                                    country = COUNTRY_MAPPING[country_code]
                                
                                location_parts = []
                                if country:
                                    location_parts.append(country)
                                
                                # ä¼˜å…ˆä½¿ç”¨åŸå¸‚
                                if city and city.strip():
                                    location_parts.append(city.strip())
                                elif region_name and region_name.strip():
                                    location_parts.append(region_name.strip())
                                
                                if location_parts:
                                    location = '-'.join(location_parts)
                                    return normalize_location(location)
                except Exception as e:
                    if attempt == retry - 1:
                        print(f"    âš ï¸  ip-api.com æŸ¥è¯¢å¤±è´¥: {e}")
                    await asyncio.sleep(1)
            
            # æ–¹æ³•2: ä½¿ç”¨ ipinfo.io ä½œä¸ºå¤‡ç”¨
            for attempt in range(retry):
                try:
                    async with session.get(f'https://ipinfo.io/{ip}/json', 
                                          timeout=aiohttp.ClientTimeout(total=10)) as response:
                        if response.status == 200:
                            data = await response.json()
                            country_code = data.get('country', '')
                            city = data.get('city', '')
                            region = data.get('region', '')
                            
                            if country_code:
                                country_name = COUNTRY_MAPPING.get(country_code, country_code)
                                
                                location_parts = [country_name]
                                
                                # ä¼˜å…ˆä½¿ç”¨åŸå¸‚ï¼Œå…¶æ¬¡ä½¿ç”¨åœ°åŒº
                                if city and city.strip():
                                    location_parts.append(city.strip())
                                elif region and region.strip():
                                    location_parts.append(region.strip())
                                
                                location = '-'.join(location_parts)
                                return normalize_location(location)
                except Exception as e:
                    if attempt == retry - 1:
                        print(f"    âš ï¸  ipinfo.io æŸ¥è¯¢å¤±è´¥: {e}")
                    await asyncio.sleep(1)
            
            # æ–¹æ³•3: ä½¿ç”¨ ipapi.co ä½œä¸ºæœ€åå¤‡ç”¨
            try:
                async with session.get(f'https://ipapi.co/{ip}/json/', 
                                      timeout=aiohttp.ClientTimeout(total=10)) as response:
                    if response.status == 200:
                        data = await response.json()
                        country = data.get('country_name', '')
                        city = data.get('city', '')
                        region = data.get('region', '')
                        country_code = data.get('country_code', '')
                        
                        # å°è¯•è½¬æ¢ä¸ºä¸­æ–‡
                        if country_code and country_code in COUNTRY_MAPPING:
                            country = COUNTRY_MAPPING[country_code]
                        
                        location_parts = []
                        if country:
                            location_parts.append(country)
                        if city and city.strip():
                            location_parts.append(city.strip())
                        elif region and region.strip():
                            location_parts.append(region.strip())
                        
                        if location_parts:
                            location = '-'.join(location_parts)
                            return normalize_location(location)
            except Exception as e:
                print(f"    âš ï¸  ipapi.co æŸ¥è¯¢å¤±è´¥: {e}")
            
            return 'Unknown'

        def measure_tcp_latency(ip: str, port: int, timeout: float = 3.0) -> Optional[float]:
            """æµ‹é‡TCPè¿æ¥å»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰"""
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                
                start_time = time.time()
                result = sock.connect_ex((ip, port))
                end_time = time.time()
                
                sock.close()
                
                if result == 0:
                    latency_ms = (end_time - start_time) * 1000
                    return round(latency_ms, 2)
                else:
                    return None
            except Exception:
                return None

        def test_tcp_connectivity(ip: str, port: int, timeout: float = 3.0) -> bool:
            """æµ‹è¯•TCPè¿æ¥"""
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                result = sock.connect_ex((ip, port))
                sock.close()
                return result == 0
            except Exception:
                return False

        def measure_latency_via_dns(ip: str, port: int, dns_server: str, timeout: float = 5.0, test_count: int = 3) -> Optional[float]:
            """é€šè¿‡æŒ‡å®šDNSæœåŠ¡å™¨æµ‹é‡å»¶è¿Ÿï¼ˆå¤šæ¬¡æµ‹è¯•å–å¹³å‡å€¼ï¼‰"""
            latencies = []
            
            for _ in range(test_count):
                try:
                    # é…ç½®ä½¿ç”¨æŒ‡å®šçš„DNSæœåŠ¡å™¨
                    resolver = dns.resolver.Resolver()
                    resolver.nameservers = [dns_server]
                    resolver.timeout = 2
                    resolver.lifetime = 2
                    
                    # æµ‹é‡è¿æ¥å»¶è¿Ÿ
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(timeout)
                    
                    start_time = time.time()
                    result = sock.connect_ex((ip, port))
                    end_time = time.time()
                    
                    sock.close()
                    
                    if result == 0:
                        latency_ms = (end_time - start_time) * 1000
                        latencies.append(latency_ms)
                    
                    time.sleep(0.1)  # çŸ­æš‚å»¶è¿Ÿ
                    
                except Exception:
                    pass
            
            if latencies:
                # è¿”å›å¹³å‡å»¶è¿Ÿ
                avg_latency = sum(latencies) / len(latencies)
                return round(avg_latency, 2)
            else:
                return None

        def test_isp_connectivity_with_latency(ip: str, port: int) -> Dict[str, Dict]:
            """æµ‹è¯•IPå¯¹ä¸‰å¤§è¿è¥å•†çš„è¿é€šæ€§å’Œå»¶è¿Ÿ"""
            results = {}
            
            print(f"    æµ‹è¯•è¿è¥å•†è¿é€šæ€§å’Œå»¶è¿Ÿ:")
            
            for isp_name, dns_servers in ISP_DNS.items():
                # ä½¿ç”¨è¯¥è¿è¥å•†çš„DNSæœåŠ¡å™¨è¿›è¡Œæµ‹è¯•
                best_latency = None
                
                for dns_server in dns_servers:
                    latency = measure_latency_via_dns(ip, port, dns_server, timeout=5.0, test_count=3)
                    
                    if latency is not None:
                        if best_latency is None or latency < best_latency:
                            best_latency = latency
                
                is_connected = best_latency is not None
                results[isp_name] = {
                    'connected': is_connected,
                    'latency': best_latency
                }
                
                status = "âœ…" if is_connected else "âŒ"
                latency_str = f"{best_latency:.0f}ms" if best_latency else "ä¸é€š"
                print(f"      {status} {isp_name}: {latency_str}")
            
            return results

        async def test_ip_connectivity(ip_data: Dict, session: aiohttp.ClientSession) -> Optional[Dict]:
            """æµ‹è¯•å•ä¸ªIPçš„è¿é€šæ€§å’Œå»¶è¿Ÿ"""
            ip = ip_data['ip']
            port = int(ip_data['port'])
            
            print(f"\n{'='*60}")
            print(f"ğŸ” æµ‹è¯• IP: {ip}:{port}")
            print(f"{'='*60}")
            
            # å…ˆè¿›è¡ŒåŸºç¡€è¿é€šæ€§æµ‹è¯•
            print(f"  [1/4] åŸºç¡€è¿é€šæ€§æµ‹è¯•...", end=' ')
            is_connected = test_tcp_connectivity(ip, port, timeout=5.0)
            
            if not is_connected:
                print("âŒ å¤±è´¥")
                return None
            
            print("âœ… æˆåŠŸ")
            
            # æµ‹è¯•ä¸‰å¤§è¿è¥å•†çš„è¿é€šæ€§å’Œå»¶è¿Ÿ
            print(f"  [2/4] ä¸‰ç½‘è¿é€šæ€§å’Œå»¶è¿Ÿæµ‹è¯•:")
            isp_results = test_isp_connectivity_with_latency(ip, port)
            
            # æ£€æŸ¥æ˜¯å¦å…¨éƒ¨è”é€š
            all_connected = all(result['connected'] for result in isp_results.values())
            
            if not all_connected:
                failed_isps = [isp for isp, result in isp_results.items() if not result['connected']]
                print(f"      âš ï¸  éƒ¨åˆ†è¿è¥å•†ä¸é€š: {', '.join(failed_isps)}")
                print(f"      âŒ æœªé€šè¿‡ä¸‰ç½‘æµ‹è¯•ï¼Œè·³è¿‡")
                return None
            
            # è®¡ç®—å¹³å‡å»¶è¿Ÿ
            latencies = [result['latency'] for result in isp_results.values() if result['latency'] is not None]
            avg_latency = round(sum(latencies) / len(latencies), 2) if latencies else 0
            
            print(f"      âœ… ç”µä¿¡ã€è”é€šã€ç§»åŠ¨å…¨éƒ¨è”é€š")
            print(f"      ğŸ“Š å¹³å‡å»¶è¿Ÿ: {avg_latency:.0f}ms")
            
            # å¼ºåˆ¶é‡æ–°æŸ¥è¯¢åœ°ç†ä½ç½®ï¼ˆå¿½ç•¥åŸæœ‰æ•°æ®ï¼‰
            print(f"  [3/4] æŸ¥è¯¢åœ°ç†ä½ç½®ä¿¡æ¯...")
            location = await get_ip_location(session, ip, retry=3)
            
            if location == 'Unknown':
                print(f"      âš ï¸  æ— æ³•è·å–åœ°ç†ä½ç½®ï¼Œè·³è¿‡")
                return None
            
            print(f"      ğŸ“ ä½ç½®: {location}")
            
            # éªŒè¯æ ¼å¼
            print(f"  [4/4] éªŒè¯æ•°æ®æ ¼å¼...", end=' ')
            if not location or location == 'Unknown' or '-' not in location:
                print(f"âŒ æ ¼å¼å¼‚å¸¸")
                return None
            
            print(f"âœ… é€šè¿‡")
            print(f"  ğŸ‰ æ­¤IPé€šè¿‡æ‰€æœ‰æµ‹è¯•ï¼")
            
            return {
                'ip': ip,
                'port': port,
                'location': location,
                'isp_results': isp_results,
                'avg_latency': avg_latency
            }

        def filter_best_ips_by_location(valid_ips: List[Dict], max_per_location: int = MAX_IPS_PER_LOCATION) -> List[Dict]:
            """æŒ‰åœ°ç†ä½ç½®åˆ†ç»„ï¼Œä¿ç•™æ¯ä¸ªåœ°åŒºå»¶è¿Ÿæœ€ä½çš„IP"""
            # æŒ‰åœ°ç†ä½ç½®åˆ†ç»„
            by_location = {}
            for ip_info in valid_ips:
                location = ip_info['location']
                if location not in by_location:
                    by_location[location] = []
                by_location[location].append(ip_info)
            
            # å¯¹æ¯ä¸ªåœ°åŒºæŒ‰å»¶è¿Ÿæ’åºï¼Œä¿ç•™æœ€ä¼˜çš„IP
            filtered_ips = []
            for location, ips in by_location.items():
                # æŒ‰å¹³å‡å»¶è¿Ÿæ’åº
                sorted_ips = sorted(ips, key=lambda x: x['avg_latency'])
                # ä¿ç•™å»¶è¿Ÿæœ€ä½çš„æœ€å¤šmax_per_locationä¸ª
                best_ips = sorted_ips[:max_per_location]
                filtered_ips.extend(best_ips)
                
                if len(ips) > max_per_location:
                    print(f"  ğŸ“ {location}: ä¿ç•™æœ€ä¼˜ {max_per_location}/{len(ips)} ä¸ªIP (å»¶è¿Ÿ: {best_ips[0]['avg_latency']:.0f}ms - {best_ips[-1]['avg_latency']:.0f}ms)")
                else:
                    print(f"  ğŸ“ {location}: ä¿ç•™å…¨éƒ¨ {len(ips)} ä¸ªIP")
            
            return filtered_ips

        async def main():
            print("=" * 60)
            print("ğŸš€ å¼€å§‹æµ‹è¯• IP è¿é€šæ€§å’Œå»¶è¿Ÿ")
            print("=" * 60)
            
            # ä» api.txt åŠ è½½ API åˆ—è¡¨
            api_urls = load_api_list('api.txt')
            
            if not api_urls:
                print("âŒ æ²¡æœ‰å¯ç”¨çš„ APIï¼Œè¯·æ£€æŸ¥ api.txt æ–‡ä»¶")
                return
            
            all_ips = []
            seen_ips = set()
            
            # æ”¶é›†æ‰€æœ‰IP
            async with aiohttp.ClientSession() as session:
                print(f"\nğŸ“¥ æ­£åœ¨ä» {len(api_urls)} ä¸ª API è·å– IP åˆ—è¡¨...")
                print("-" * 60)
                
                for idx, api_url in enumerate(api_urls, 1):
                    print(f"[{idx}/{len(api_urls)}] {api_url}")
                    content = await fetch_url(session, api_url)
                    
                    if not content:
                        continue
                    
                    lines = content.split('\n')
                    count_before = len(all_ips)
                    
                    for line in lines:
                        ip_data = parse_ip_line(line)
                        if ip_data and ip_data['ip'] not in seen_ips:
                            seen_ips.add(ip_data['ip'])
                            all_ips.append(ip_data)
                    
                    new_ips = len(all_ips) - count_before
                    if new_ips > 0:
                        print(f"  âœ… æ–°å¢ {new_ips} ä¸ª IP")
                    else:
                        print(f"  âš ï¸  æœªè·å–åˆ°æ–° IP")
                
                print("-" * 60)
                print(f"âœ… å…±æ”¶é›†åˆ° {len(all_ips)} ä¸ªå”¯ä¸€ IP")
                
                if len(all_ips) == 0:
                    print("âŒ æ²¡æœ‰æ”¶é›†åˆ°ä»»ä½• IPï¼Œè¯·æ£€æŸ¥ API æ˜¯å¦æ­£å¸¸")
                    with open('ip.txt', 'w', encoding='utf-8') as f:
                        f.write(f"# æµ‹è¯•æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                        f.write("# æœªæ”¶é›†åˆ°ä»»ä½• IP æ•°æ®\n")
                    return
                
                # æµ‹è¯•è¿é€šæ€§å’Œå»¶è¿Ÿ
                print("\nğŸ”„ å¼€å§‹æµ‹è¯•ä¸‰ç½‘è¿é€šæ€§å’Œå»¶è¿Ÿ...")
                print("=" * 60)
                print("è¯´æ˜: åªä¿ç•™ç”µä¿¡ã€è”é€šã€ç§»åŠ¨ä¸‰ç½‘å…¨é€šçš„IP")
                print(f"ç­–ç•¥: æ¯ä¸ªåœ°åŒºä¿ç•™å»¶è¿Ÿæœ€ä½çš„æœ€å¤š {MAX_IPS_PER_LOCATION} ä¸ªIP")
                print("=" * 60)
                
                valid_ips = []
                
                # åˆ†æ‰¹å¤„ç†ï¼Œé¿å…å¹¶å‘è¿‡é«˜
                batch_size = 10  # é™ä½å¹¶å‘æ•°ï¼Œå› ä¸ºæ¯ä¸ªIPè¦æµ‹è¯•3ä¸ªè¿è¥å•†
                for i in range(0, len(all_ips), batch_size):
                    batch = all_ips[i:i+batch_size]
                    batch_tasks = [test_ip_connectivity(ip_data, session) for ip_data in batch]
                    results = await asyncio.gather(*batch_tasks)
                    valid_ips.extend([r for r in results if r is not None])
                    
                    # è¿›åº¦æ˜¾ç¤º
                    progress = min(i + batch_size, len(all_ips))
                    print(f"\n{'='*60}")
                    print(f"ğŸ“Š è¿›åº¦: {progress}/{len(all_ips)} ({progress*100//len(all_ips)}%) | ä¸‰ç½‘å…¨é€š IP: {len(valid_ips)}")
                    print(f"{'='*60}")
                    
                    # çŸ­æš‚å»¶è¿Ÿï¼Œé¿å…è¯·æ±‚è¿‡å¿«
                    await asyncio.sleep(1)
            
            print("\n" + "=" * 60)
            print(f"âœ… æµ‹è¯•å®Œæˆï¼")
            print(f"ğŸ“Š æ€»æµ‹è¯•æ•°: {len(all_ips)}")
            print(f"âœ… ä¸‰ç½‘å…¨é€š: {len(valid_ips)}")
            print(f"ğŸ“ˆ é€šè¿‡ç‡: {len(valid_ips)*100//len(all_ips) if all_ips else 0}%")
            print("=" * 60)
            
            # æŒ‰åœ°åŒºè¿‡æ»¤ï¼Œä¿ç•™å»¶è¿Ÿæœ€ä¼˜çš„IP
            if valid_ips:
                print(f"\nğŸ¯ å¼€å§‹æŒ‰åœ°åŒºä¼˜é€‰IP (æ¯ä¸ªåœ°åŒºæœ€å¤šä¿ç•™{MAX_IPS_PER_LOCATION}ä¸ª)...")
                print("-" * 60)
                filtered_ips = filter_best_ips_by_location(valid_ips, MAX_IPS_PER_LOCATION)
                print("-" * 60)
                print(f"âœ… ä¼˜é€‰å®Œæˆ: {len(filtered_ips)}/{len(valid_ips)} ä¸ªIP")
            else:
                filtered_ips = []
            
            # å†™å…¥æ–‡ä»¶
            with open('ip.txt', 'w', encoding='utf-8') as f:
                # å†™å…¥å¤´éƒ¨ä¿¡æ¯
                f.write(f"# IP ä¸‰ç½‘è¿é€šæ€§å’Œå»¶è¿Ÿæµ‹è¯•ç»“æœ\n")
                f.write(f"# æµ‹è¯•æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"# æ€»æµ‹è¯•æ•°: {len(all_ips)}\n")
                f.write(f"# ä¸‰ç½‘å…¨é€š: {len(valid_ips)}\n")
                f.write(f"# ä¼˜é€‰ä¿ç•™: {len(filtered_ips)}\n")
                f.write(f"# é€šè¿‡ç‡: {len(valid_ips)*100//len(all_ips) if all_ips else 0}%\n")
                f.write(f"# è¿è¥å•†: ä¸­å›½ç”µä¿¡ âœ“ | ä¸­å›½è”é€š âœ“ | ä¸­å›½ç§»åŠ¨ âœ“\n")
                f.write(f"# ä¼˜é€‰ç­–ç•¥: æ¯ä¸ªåœ°åŒºä¿ç•™å»¶è¿Ÿæœ€ä½çš„æœ€å¤š {MAX_IPS_PER_LOCATION} ä¸ªIP\n")
                f.write(f"# æ ¼å¼: IP:ç«¯å£#å›½å®¶-åœ°åŒº (ç”µä¿¡å»¶è¿Ÿ|è”é€šå»¶è¿Ÿ|ç§»åŠ¨å»¶è¿Ÿ|å¹³å‡å»¶è¿Ÿ)\n")
                f.write("#" + "=" * 58 + "\n\n")
                
                if filtered_ips:
                    # æŒ‰åœ°ç†ä½ç½®åˆ†ç»„å¹¶æ’åº
                    by_location = {}
                    for ip_info in filtered_ips:
                        location = ip_info['location']
                        if location not in by_location:
                            by_location[location] = []
                        by_location[location].append(ip_info)
                    
                    # æŒ‰å›½å®¶å’ŒåŸå¸‚æ’åº
                    sorted_locations = sorted(by_location.keys(), key=lambda x: (
                        x.split('-')[0],  # å…ˆæŒ‰å›½å®¶æ’åº
                        x.split('-')[1] if '-' in x and len(x.split('-')) > 1 else ''  # å†æŒ‰åŸå¸‚æ’åº
                    ))
                    
                    # å†™å…¥åˆ†ç»„åçš„IP
                    for location in sorted_locations:
                        ips = by_location[location]
                        f.write(f"# {location} ({len(ips)}ä¸ª)\n")
                        
                        # å¯¹æ¯ä¸ªä½ç½®çš„IPæŒ‰å¹³å‡å»¶è¿Ÿæ’åºï¼ˆä½†ä¸åœ¨æ–‡ä»¶ä¸­æ˜¾ç¤ºå»¶è¿Ÿï¼‰
                        sorted_ips = sorted(ips, key=lambda x: x['avg_latency'])
                        
                        for ip_info in sorted_ips:
                            # ç»Ÿä¸€æ ¼å¼: IP:ç«¯å£#å›½å®¶-åŸå¸‚ï¼ˆä¸åŒ…å«å»¶è¿Ÿæ•°æ®ï¼‰
                            line = f"{ip_info['ip']}:{ip_info['port']}#{ip_info['location']}"
                            f.write(f"{line}\n")
                        f.write("\n")
                    
                    print(f"\nğŸ’¾ ç»“æœå·²ä¿å­˜åˆ° ip.txt")
                    
                    # è¾“å‡ºç»Ÿè®¡ä¿¡æ¯ï¼ˆæŒ‰å›½å®¶æ±‡æ€»ï¼‰
                    print("\nğŸ“Š åœ°ç†ä½ç½®åˆ†å¸ƒç»Ÿè®¡:")
                    country_stats = {}
                    for location, ips in by_location.items():
                        country = location.split('-')[0]
                        if country not in country_stats:
                            country_stats[country] = {'count': 0, 'latencies': []}
                        country_stats[country]['count'] += len(ips)
                        for ip in ips:
                            country_stats[country]['latencies'].append(ip['avg_latency'])
                    
                    # æŒ‰æ•°é‡æ’åº
                    for country, stats in sorted(country_stats.items(), key=lambda x: x[1]['count'], reverse=True):
                        avg_latency = sum(stats['latencies']) / len(stats['latencies'])
                        print(f"  ğŸŒ {country}: {stats['count']} ä¸ª (å¹³å‡å»¶è¿Ÿ: {avg_latency:.0f}ms)")
                    
                    # è¯¦ç»†åŸå¸‚åˆ†å¸ƒ
                    print("\nğŸ“ è¯¦ç»†åŸå¸‚åˆ†å¸ƒ (å»¶è¿Ÿæœ€ä¼˜å‰20):")
                    # æŒ‰å¹³å‡å»¶è¿Ÿæ’åºæ‰€æœ‰åœ°åŒº
                    location_with_latency = []
                    for location, ips in by_location.items():
                        avg_latency = sum(ip['avg_latency'] for ip in ips) / len(ips)
                        location_with_latency.append((location, len(ips), avg_latency))
                    
                    location_with_latency.sort(key=lambda x: x[2])  # æŒ‰å»¶è¿Ÿæ’åº
                    
                    for location, count, avg_lat in location_with_latency[:20]:
                        print(f"  ğŸ“Œ {location}: {count} ä¸ª (å¹³å‡: {avg_lat:.0f}ms)")
                    
                    # å»¶è¿Ÿç»Ÿè®¡
                    all_latencies = [ip['avg_latency'] for ip in filtered_ips]
                    print("\nâ±ï¸  å»¶è¿Ÿç»Ÿè®¡:")
                    print(f"  ğŸ† æœ€ä½å»¶è¿Ÿ: {min(all_latencies):.0f}ms")
                    print(f"  ğŸ“Š å¹³å‡å»¶è¿Ÿ: {sum(all_latencies)/len(all_latencies):.0f}ms")
                    print(f"  ğŸ“ˆ æœ€é«˜å»¶è¿Ÿ: {max(all_latencies):.0f}ms")
                    
                else:
                    f.write("# æœªæ‰¾åˆ°ä¸‰ç½‘å…¨é€šçš„ IP\n")
                    print("\nâš ï¸  æ²¡æœ‰æ‰¾åˆ°ä¸‰ç½‘å…¨é€šçš„ IP")

        if __name__ == '__main__':
            asyncio.run(main())
        EOF

    - name: Run IP connectivity test
      run: |
        python test_ip.py

    - name: Check if ip.txt exists and has valid data
      id: check_file
      run: |
        if [ -f ip.txt ]; then
          # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦æœ‰å®é™…çš„IPæ•°æ®ï¼ˆæ’é™¤æ³¨é‡Šè¡Œï¼‰
          valid_lines=$(grep -v '^#' ip.txt | grep -E '^\s*[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' | wc -l)
          
          if [ "$valid_lines" -gt 0 ]; then
            echo "file_exists=true" >> $GITHUB_OUTPUT
            echo "âœ… ip.txt æ–‡ä»¶å·²ç”Ÿæˆï¼ŒåŒ…å« $valid_lines ä¸ªæœ‰æ•ˆ IP"
            echo "ip_count=$valid_lines" >> $GITHUB_OUTPUT
          else
            echo "file_exists=false" >> $GITHUB_OUTPUT
            echo "âš ï¸  ip.txt æ–‡ä»¶å·²ç”Ÿæˆï¼Œä½†æ²¡æœ‰æœ‰æ•ˆçš„ IP æ•°æ®"
            echo "ip_count=0" >> $GITHUB_OUTPUT
          fi
          
          echo "ğŸ“„ æ–‡ä»¶å†…å®¹é¢„è§ˆ:"
          head -n 30 ip.txt
        else
          echo "file_exists=false" >> $GITHUB_OUTPUT
          echo "ip_count=0" >> $GITHUB_OUTPUT
          echo "âŒ ip.txt æ–‡ä»¶æœªç”Ÿæˆ"
        fi

    - name: Create Release
      if: steps.check_file.outputs.file_exists == 'true'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ github.run_number }}-${{ github.run_id }}
        name: IP List ${{ github.run_number }} - ${{ steps.check_file.outputs.ip_count }} IPs (ä¸‰ç½‘å…¨é€š+å»¶è¿Ÿä¼˜é€‰)
        body: |
          ## ğŸ“‹ IP ä¸‰ç½‘è¿é€šæ€§å’Œå»¶è¿Ÿæµ‹è¯•ç»“æœ
          
          **æµ‹è¯•æ—¶é—´:** `${{ github.event.repository.updated_at }}`  
          **è¿è¡Œç¼–å·:** #${{ github.run_number }}  
          **ä¼˜é€‰ IP:** ${{ steps.check_file.outputs.ip_count }} ä¸ª
          
          ### ğŸ“Š æµ‹è¯•è¯´æ˜
          - âœ… æ‰€æœ‰ IP å‡é€šè¿‡ä¸­å›½ä¸‰å¤§è¿è¥å•†è¿é€šæ€§æµ‹è¯•
          - ğŸŒ **ä¸­å›½ç”µä¿¡** âœ“ | **ä¸­å›½è”é€š** âœ“ | **ä¸­å›½ç§»åŠ¨** âœ“
          - â±ï¸ åŒ…å«æ¯ä¸ªIPå¯¹ä¸‰ç½‘çš„å»¶è¿Ÿæ•°æ®ï¼ˆæ¯«ç§’ï¼‰
          - ğŸ“ åŒ…å«è¯¦ç»†åœ°ç†ä½ç½®ä¿¡æ¯ï¼ˆå›½å®¶-åŸå¸‚/åœ°åŒºï¼‰
          - ğŸ¯ **æ™ºèƒ½ä¼˜é€‰**: æ¯ä¸ªåœ°åŒºä¿ç•™å»¶è¿Ÿæœ€ä½çš„æœ€å¤š5ä¸ªIP
          - ğŸ“ æ ¼å¼: `IP:ç«¯å£#å›½å®¶-åœ°åŒº (ç”µä¿¡å»¶è¿Ÿ|è”é€šå»¶è¿Ÿ|ç§»åŠ¨å»¶è¿Ÿ|å¹³å‡å»¶è¿Ÿ)`
          - ğŸ”„ æ¯å¤©åŒ—äº¬æ—¶é—´å‡Œæ™¨ 3 ç‚¹è‡ªåŠ¨æ›´æ–°
          
          ### ğŸ¯ è´¨é‡ä¿è¯
          - åªä¿ç•™**ä¸‰ç½‘å…¨é€š**çš„ IP åœ°å€
          - æ¯ä¸ª IP éƒ½ç»è¿‡ç”µä¿¡ã€è”é€šã€ç§»åŠ¨ç½‘ç»œéªŒè¯
          - æµ‹é‡çœŸå®ç½‘ç»œå»¶è¿Ÿï¼ˆTCPè¿æ¥æ—¶é—´ï¼‰
          - æŒ‰åœ°åŒºæ™ºèƒ½ä¼˜é€‰ï¼Œä¼˜å…ˆä¿ç•™ä½å»¶è¿ŸIP
          - ç¡®ä¿å…¨å›½ç”¨æˆ·éƒ½èƒ½è·å¾—æœ€ä½³ä½“éªŒ
          
          ### ğŸ“¥ ä½¿ç”¨æ–¹æ³•
          1. ä¸‹è½½ `ip.txt` æ–‡ä»¶
          2. æŒ‰ç…§æ ¼å¼ä½¿ç”¨å…¶ä¸­çš„ IP åœ°å€
          3. æ¯ä¸ª IP éƒ½å·²éªŒè¯å¯è¿æ¥
          4. å¯æ ¹æ®å»¶è¿Ÿæ•°æ®é€‰æ‹©æœ€ä¼˜IP
          
          ### ğŸ“ˆ å»¶è¿Ÿè¯´æ˜
          - å»¶è¿Ÿå•ä½ä¸ºæ¯«ç§’(ms)
          - æ•°å€¼è¶Šå°ï¼Œè¿æ¥é€Ÿåº¦è¶Šå¿«
          - æ ¼å¼: (ç”µä¿¡|è”é€š|ç§»åŠ¨|å¹³å‡)
          - æ¯æ¬¡æµ‹è¯•å–3æ¬¡å¹³å‡å€¼ï¼Œç¡®ä¿å‡†ç¡®æ€§
          
          ### âš™ï¸ API æ¥æº
          IP æ•°æ®æ¥è‡ª `api.txt` æ–‡ä»¶ä¸­é…ç½®çš„ API æ¥å£
          
          ---
          *æ­¤ Release ç”± GitHub Actions è‡ªåŠ¨ç”Ÿæˆ ğŸ¤–*
        files: |
          ip.txt
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Keep only latest 5 releases
      if: steps.check_file.outputs.file_exists == 'true'
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const releases = await github.rest.repos.listReleases({
            owner: context.repo.owner,
            repo: context.repo.repo,
            per_page: 100
          });
          
          const sortedReleases = releases.data.sort((a, b) => 
            new Date(b.created_at) - new Date(a.created_at)
          );
          
          console.log(`Found ${sortedReleases.length} releases`);
          
          if (sortedReleases.length > 5) {
            for (let i = 5; i < sortedReleases.length; i++) {
              console.log(`Deleting release: ${sortedReleases[i].name} (${sortedReleases[i].tag_name})`);
              await github.rest.repos.deleteRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: sortedReleases[i].id
              });
              
              // åŒæ—¶åˆ é™¤å¯¹åº”çš„ tag
              try {
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `tags/${sortedReleases[i].tag_name}`
                });
                console.log(`Deleted tag: ${sortedReleases[i].tag_name}`);
              } catch (error) {
                console.log(`Could not delete tag: ${sortedReleases[i].tag_name}`);
              }
            }
            console.log(`âœ… Cleaned up ${sortedReleases.length - 5} old releases`);
          } else {
            console.log('âœ… No cleanup needed');
          }
