name: Test IP Connectivity and Create Release

on:
  schedule:
    - cron: '0 19 * * *'  # æ¯å¤©åŒ—äº¬æ—¶é—´å‡Œæ™¨3ç‚¹è¿è¡Œ (UTC 19:00 = åŒ—äº¬æ—¶é—´ 03:00)
  workflow_dispatch:  # å…è®¸æ‰‹åŠ¨è§¦å‘
  push:
    branches:
      - main
    paths:
      - '.github/workflows/ip-test.yml'
      - 'api.txt'

# æ·»åŠ å¿…è¦çš„æƒé™
permissions:
  contents: write  # å…è®¸åˆ›å»º Release å’Œä¸Šä¼ æ–‡ä»¶
  actions: read

jobs:
  test-and-release:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        pip install requests aiohttp asyncio dnspython beautifulsoup4 lxml

    - name: Verify api.txt exists
      run: |
        if [ ! -f api.txt ]; then
          echo "âŒ api.txt æ–‡ä»¶ä¸å­˜åœ¨ï¼Œæ­£åœ¨åˆ›å»ºç¤ºä¾‹æ–‡ä»¶..."
          cat > api.txt << 'APIEOF'
        # API åˆ—è¡¨é…ç½®æ–‡ä»¶
        # æ¯è¡Œä¸€ä¸ª API åœ°å€ï¼Œ# å¼€å¤´çš„è¡Œä¸ºæ³¨é‡Š
        # 
        # CloudFlare IP ä¼˜é€‰ API
        https://raw.githubusercontent.com/ymyuuu/IPDB/refs/heads/main/bestproxy.txt
        https://raw.githubusercontent.com/ymyuuu/IPDB/refs/heads/main/bestcf.txt
        https://ip.164746.xyz/ipTop10.html
        https://raw.githubusercontent.com/ZhiXuanWang/cf-speed-dns/refs/heads/main/ipTop10.html
        https://vps789.com/public/sum/cfIpApi
        # https://www.wetest.vip/api/cf2dns/get_cloudflare_ip&type=v4&key=o1zrmHAF
        https://raw.githubusercontent.com/cmliu/WorkerVless2sub/main/addressesapi.txt
        https://addressesapi.090227.xyz/CloudFlareYes
        https://addressesapi.090227.xyz/ip.164746.xyz
        APIEOF
          echo "âœ… å·²åˆ›å»ºç¤ºä¾‹ api.txt æ–‡ä»¶"
        fi
        echo "ğŸ“‹ API åˆ—è¡¨å†…å®¹ï¼š"
        cat api.txt

    - name: Create test script
      run: |
        cat > test_ip.py << 'EOF'
        import asyncio
        import aiohttp
        import json
        import re
        import socket
        from datetime import datetime
        from typing import List, Dict, Optional, Tuple
        import time
        import os
        import dns.resolver
        from bs4 import BeautifulSoup

        # æ¯ä¸ªåœ°åŒºä¿ç•™çš„æœ€å¤§IPæ•°é‡
        MAX_IPS_PER_LOCATION = 5

        # ä¸­å›½ä¸‰å¤§è¿è¥å•†çš„å…¬å…± DNS æœåŠ¡å™¨
        ISP_DNS = {
            'ç”µä¿¡': ['114.114.114.114', '114.114.115.115'],
            'è”é€š': ['123.123.123.123', '123.125.81.6'],
            'ç§»åŠ¨': ['221.179.155.161', '112.4.0.55']
        }

        # å›½å®¶ä»£ç æ˜ å°„
        COUNTRY_MAPPING = {
            'CN': 'ä¸­å›½', 'HK': 'é¦™æ¸¯', 'TW': 'å°æ¹¾', 'JP': 'æ—¥æœ¬', 'KR': 'éŸ©å›½',
            'SG': 'æ–°åŠ å¡', 'MY': 'é©¬æ¥è¥¿äºš', 'TH': 'æ³°å›½', 'VN': 'è¶Šå—', 'ID': 'å°å°¼',
            'IN': 'å°åº¦', 'PH': 'è²å¾‹å®¾', 'US': 'ç¾å›½', 'CA': 'åŠ æ‹¿å¤§', 'MX': 'å¢¨è¥¿å“¥',
            'DE': 'å¾·å›½', 'GB': 'è‹±å›½', 'FR': 'æ³•å›½', 'IT': 'æ„å¤§åˆ©', 'ES': 'è¥¿ç­ç‰™',
            'PT': 'è‘¡è„ç‰™', 'NL': 'è·å…°', 'BE': 'æ¯”åˆ©æ—¶', 'SE': 'ç‘å…¸', 'NO': 'æŒªå¨',
            'AU': 'æ¾³å¤§åˆ©äºš', 'NZ': 'æ–°è¥¿å…°', 'BR': 'å·´è¥¿', 'AR': 'é˜¿æ ¹å»·', 'RU': 'ä¿„ç½—æ–¯',
            'CH': 'ç‘å£«', 'AT': 'å¥¥åœ°åˆ©', 'DK': 'ä¸¹éº¦', 'FI': 'èŠ¬å…°', 'IE': 'çˆ±å°”å…°',
            'PL': 'æ³¢å…°', 'CZ': 'æ·å…‹', 'TR': 'åœŸè€³å…¶', 'AE': 'é˜¿è”é…‹', 'IL': 'ä»¥è‰²åˆ—',
            'ZA': 'å—é', 'EG': 'åŸƒåŠ', 'SA': 'æ²™ç‰¹', 'UA': 'ä¹Œå…‹å…°', 'GR': 'å¸Œè…Š'
        }

        def load_api_list(filename: str = 'api.txt') -> List[str]:
            """ä» api.txt åŠ è½½ API åˆ—è¡¨"""
            api_urls = []
            
            if not os.path.exists(filename):
                print(f"âŒ {filename} æ–‡ä»¶ä¸å­˜åœ¨")
                return api_urls
            
            with open(filename, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        api_urls.append(line)
            
            print(f"âœ… ä» {filename} åŠ è½½äº† {len(api_urls)} ä¸ª API")
            return api_urls

        def is_valid_ip(ip: str) -> bool:
            """éªŒè¯IPåœ°å€æ ¼å¼"""
            parts = ip.split('.')
            if len(parts) != 4:
                return False
            for part in parts:
                try:
                    num = int(part)
                    if num < 0 or num > 255:
                        return False
                    if len(part) > 1 and part[0] == '0':
                        return False
                except ValueError:
                    return False
            return True

        def is_valid_port(port: str) -> bool:
            """éªŒè¯ç«¯å£å·æ ¼å¼"""
            try:
                num = int(port)
                return 0 < num <= 65535
            except ValueError:
                return False

        def parse_ip_line(line: str) -> Optional[Dict]:
            """è§£æIPè¡Œï¼Œæ”¯æŒå¤šç§æ ¼å¼"""
            line = line.strip()
            
            if not line or line.startswith(('#', '//', '<!--', 'http')):
                return None
            
            # æ¨¡å¼1: IP:Port#Country
            match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)#(.+)$', line)
            if match:
                ip, port, country = match.groups()
                if is_valid_ip(ip) and is_valid_port(port):
                    return {'ip': ip, 'port': port, 'country': country.strip()}
            
            # æ¨¡å¼2: IP#Country
            match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})#(.+)$', line)
            if match:
                ip, country = match.groups()
                if is_valid_ip(ip):
                    return {'ip': ip, 'port': '443', 'country': country.strip()}
            
            # æ¨¡å¼3: IP:Port
            match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)', line)
            if match:
                ip, port = match.groups()
                if is_valid_ip(ip) and is_valid_port(port):
                    return {'ip': ip, 'port': port, 'country': None}
            
            # æ¨¡å¼4: å•ç‹¬IP
            match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})$', line)
            if match:
                ip = match.group(1)
                if is_valid_ip(ip):
                    return {'ip': ip, 'port': '443', 'country': None}
            
            return None

        async def fetch_url(session: aiohttp.ClientSession, url: str) -> str:
            """å¼‚æ­¥è·å–URLå†…å®¹"""
            try:
                async with session.get(url, timeout=aiohttp.ClientTimeout(total=30)) as response:
                    if response.status == 200:
                        return await response.text()
                    else:
                        print(f"âš ï¸  {url} è¿”å›çŠ¶æ€ç : {response.status}")
            except asyncio.TimeoutError:
                print(f"â±ï¸  {url} è¯·æ±‚è¶…æ—¶")
            except Exception as e:
                print(f"âŒ è·å– {url} å¤±è´¥: {e}")
            return ""

        def normalize_location(location: str) -> str:
            """æ ‡å‡†åŒ–åœ°ç†ä½ç½®æ ¼å¼"""
            if not location or location == 'Unknown':
                return 'Unknown'
            
            location = location.strip()
            location = re.sub(r'\s+', ' ', location)
            
            if '-' not in location and ' ' in location:
                parts = location.split(' ', 1)
                location = '-'.join(parts)
            
            return location

        async def get_ip_location(session: aiohttp.ClientSession, ip: str, retry: int = 2) -> str:
            """è·å–IPè¯¦ç»†åœ°ç†ä½ç½®"""
            
            for attempt in range(retry):
                try:
                    async with session.get(f'http://ip-api.com/json/{ip}?lang=zh-CN&fields=status,country,regionName,city,countryCode', 
                                          timeout=aiohttp.ClientTimeout(total=10)) as response:
                        if response.status == 200:
                            data = await response.json()
                            if data.get('status') == 'success':
                                country = data.get('country', '')
                                region_name = data.get('regionName', '')
                                city = data.get('city', '')
                                country_code = data.get('countryCode', '')
                                
                                if country_code and country_code in COUNTRY_MAPPING:
                                    country = COUNTRY_MAPPING[country_code]
                                
                                location_parts = []
                                if country:
                                    location_parts.append(country)
                                
                                if city and city.strip():
                                    location_parts.append(city.strip())
                                elif region_name and region_name.strip():
                                    location_parts.append(region_name.strip())
                                
                                if location_parts:
                                    location = '-'.join(location_parts)
                                    return normalize_location(location)
                except Exception as e:
                    if attempt == retry - 1:
                        print(f"    âš ï¸  ip-api.com æŸ¥è¯¢å¤±è´¥: {e}")
                    await asyncio.sleep(1)
            
            return 'Unknown'

        def measure_latency_via_dns(ip: str, port: int, dns_server: str, timeout: float = 5.0, test_count: int = 3) -> Optional[float]:
            """é€šè¿‡æŒ‡å®šDNSæœåŠ¡å™¨æµ‹é‡å»¶è¿Ÿ"""
            latencies = []
            
            for _ in range(test_count):
                try:
                    resolver = dns.resolver.Resolver()
                    resolver.nameservers = [dns_server]
                    resolver.timeout = 2
                    resolver.lifetime = 2
                    
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(timeout)
                    
                    start_time = time.time()
                    result = sock.connect_ex((ip, port))
                    end_time = time.time()
                    
                    sock.close()
                    
                    if result == 0:
                        latency_ms = (end_time - start_time) * 1000
                        latencies.append(latency_ms)
                    
                    time.sleep(0.1)
                    
                except Exception:
                    pass
            
            if latencies:
                avg_latency = sum(latencies) / len(latencies)
                return round(avg_latency, 2)
            else:
                return None

        def test_isp_connectivity_with_latency(ip: str, port: int) -> Dict[str, Dict]:
            """æµ‹è¯•IPå¯¹ä¸‰å¤§è¿è¥å•†çš„è¿é€šæ€§å’Œå»¶è¿Ÿ"""
            results = {}
            
            print(f"    æµ‹è¯•è¿è¥å•†è¿é€šæ€§å’Œå»¶è¿Ÿ:")
            
            for isp_name, dns_servers in ISP_DNS.items():
                best_latency = None
                
                for dns_server in dns_servers:
                    latency = measure_latency_via_dns(ip, port, dns_server, timeout=5.0, test_count=3)
                    
                    if latency is not None:
                        if best_latency is None or latency < best_latency:
                            best_latency = latency
                
                is_connected = best_latency is not None
                results[isp_name] = {
                    'connected': is_connected,
                    'latency': best_latency
                }
                
                status = "âœ…" if is_connected else "âŒ"
                latency_str = f"{best_latency:.0f}ms" if best_latency else "ä¸é€š"
                print(f"      {status} {isp_name}: {latency_str}")
            
            return results

        async def test_china_via_chinaz(session: aiohttp.ClientSession, ip: str) -> bool:
            """é€šè¿‡ç«™é•¿å·¥å…·æµ‹è¯•å›½å†…è¿é€šæ€§"""
            try:
                url = f"https://ping.chinaz.com/{ip}"
                headers = {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                }
                
                async with session.get(url, headers=headers, timeout=aiohttp.ClientTimeout(total=20)) as response:
                    if response.status != 200:
                        return False
                    
                    html = await response.text()
                    
                    # ç®€å•æ£€æŸ¥ï¼šå¦‚æœé¡µé¢åŒ…å«æˆåŠŸå“åº”çš„å…³é”®è¯
                    if 'ms' in html and ('å“åº”' in html or 'ping' in html.lower()):
                        # æ£€æŸ¥æ˜¯å¦æœ‰è¶…æ—¶è¿‡å¤š
                        timeout_count = html.count('è¶…æ—¶') + html.count('timeout')
                        success_indicators = html.count('ms')
                        
                        # å¦‚æœæˆåŠŸæŒ‡æ ‡å¤šäºè¶…æ—¶ï¼Œè®¤ä¸ºå¯è®¿é—®
                        if success_indicators > timeout_count:
                            return True
                    
                    return False
                    
            except Exception as e:
                print(f"      ç«™é•¿å·¥å…·æµ‹è¯•å¼‚å¸¸: {e}")
                return False

        async def test_china_connectivity(session: aiohttp.ClientSession, ip: str, port: int) -> bool:
            """
            æµ‹è¯•å›½å†…è¿é€šæ€§
            ä½¿ç”¨å…¬å…±æµ‹è¯•ç«™ç‚¹è¿›è¡ŒéªŒè¯
            """
            print(f"    ğŸ‡¨ğŸ‡³ å›½å†…å…¬å…±ç«™ç‚¹æµ‹è¯•...")
            
            # æ–¹æ³•1: ç«™é•¿å·¥å…·
            result = await test_china_via_chinaz(session, ip)
            
            if result:
                print(f"      âœ… å›½å†…å¯è®¿é—®")
                return True
            else:
                print(f"      âŒ å›½å†…ä¸å¯è®¿é—®æˆ–æµ‹è¯•å¤±è´¥")
                return False

        def test_overseas_connectivity(ip: str, port: int, timeout: float = 5.0) -> Tuple[bool, Optional[float]]:
            """æµ‹è¯•å›½å¤–è¿é€šæ€§ï¼ˆGitHub Actionsç¯å¢ƒï¼‰"""
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                
                start_time = time.time()
                result = sock.connect_ex((ip, port))
                end_time = time.time()
                
                sock.close()
                
                if result == 0:
                    latency = round((end_time - start_time) * 1000, 2)
                    return True, latency
                else:
                    return False, None
            except Exception:
                return False, None

        async def test_ip_connectivity(ip_data: Dict, session: aiohttp.ClientSession) -> Optional[Dict]:
            """æµ‹è¯•å•ä¸ªIPçš„è¿é€šæ€§ï¼ˆå›½å†…å¤–åŒå‘æ£€æµ‹ï¼‰"""
            ip = ip_data['ip']
            port = int(ip_data['port'])
            
            print(f"\n{'='*60}")
            print(f"ğŸ” æµ‹è¯• IP: {ip}:{port}")
            print(f"{'='*60}")
            
            # 1. å›½å¤–è¿é€šæ€§æµ‹è¯•
            print(f"  [1/4] ğŸŒ å›½å¤–è¿é€šæ€§æµ‹è¯•...", end=' ')
            overseas_connected, overseas_latency = test_overseas_connectivity(ip, port, timeout=5.0)
            
            if not overseas_connected:
                print("âŒ å¤±è´¥")
                return None
            
            print(f"âœ… æˆåŠŸ ({overseas_latency:.0f}ms)")
            
            # 2. å›½å†…è¿é€šæ€§æµ‹è¯•ï¼ˆé€šè¿‡å…¬å…±æµ‹è¯•ç«™ç‚¹ï¼‰
            print(f"  [2/4] å›½å†…è¿é€šæ€§æµ‹è¯•:")
            china_accessible = await test_china_connectivity(session, ip, port)
            
            if not china_accessible:
                print(f"      ğŸš« å›½å†…ä¸å¯è®¿é—®ï¼Œç–‘ä¼¼è¢«å¢™ï¼Œè·³è¿‡")
                return None
            
            # 3. ä¸‰ç½‘å»¶è¿Ÿæµ‹è¯•
            print(f"  [3/4] ä¸‰ç½‘å»¶è¿Ÿæµ‹è¯•:")
            isp_results = test_isp_connectivity_with_latency(ip, port)
            
            # æ£€æŸ¥æ˜¯å¦å…¨éƒ¨è”é€š
            all_connected = all(result['connected'] for result in isp_results.values())
            
            if not all_connected:
                failed_isps = [isp for isp, result in isp_results.items() if not result['connected']]
                print(f"      âš ï¸  éƒ¨åˆ†è¿è¥å•†ä¸é€š: {', '.join(failed_isps)}")
                print(f"      âŒ æœªé€šè¿‡ä¸‰ç½‘æµ‹è¯•ï¼Œè·³è¿‡")
                return None
            
            # è®¡ç®—å¹³å‡å»¶è¿Ÿ
            latencies = [result['latency'] for result in isp_results.values() if result['latency'] is not None]
            avg_latency = round(sum(latencies) / len(latencies), 2) if latencies else 0
            
            print(f"      âœ… ç”µä¿¡ã€è”é€šã€ç§»åŠ¨å…¨éƒ¨è”é€š")
            print(f"      ğŸ“Š å¹³å‡å»¶è¿Ÿ: {avg_latency:.0f}ms")
            
            # 4. æŸ¥è¯¢åœ°ç†ä½ç½®
            print(f"  [4/4] æŸ¥è¯¢åœ°ç†ä½ç½®ä¿¡æ¯...")
            location = await get_ip_location(session, ip, retry=3)
            
            if location == 'Unknown':
                print(f"      âš ï¸  æ— æ³•è·å–åœ°ç†ä½ç½®ï¼Œè·³è¿‡")
                return None
            
            print(f"      ğŸ“ ä½ç½®: {location}")
            
            if not location or location == 'Unknown' or '-' not in location:
                print(f"      âŒ æ ¼å¼å¼‚å¸¸")
                return None
            
            print(f"  ğŸ‰ æ­¤IPé€šè¿‡æ‰€æœ‰æµ‹è¯•ï¼ˆå›½å†…å¤–å‡å¯è®¿é—®ï¼‰ï¼")
            
            return {
                'ip': ip,
                'port': port,
                'location': location,
                'isp_results': isp_results,
                'avg_latency': avg_latency,
                'overseas_latency': overseas_latency,
                'china_accessible': True
            }

        def filter_best_ips_by_location(valid_ips: List[Dict], max_per_location: int = MAX_IPS_PER_LOCATION) -> List[Dict]:
            """æŒ‰åœ°ç†ä½ç½®åˆ†ç»„ï¼Œä¿ç•™æ¯ä¸ªåœ°åŒºå»¶è¿Ÿæœ€ä½çš„IP"""
            by_location = {}
            for ip_info in valid_ips:
                location = ip_info['location']
                if location not in by_location:
                    by_location[location] = []
                by_location[location].append(ip_info)
            
            filtered_ips = []
            for location, ips in by_location.items():
                sorted_ips = sorted(ips, key=lambda x: x['avg_latency'])
                best_ips = sorted_ips[:max_per_location]
                filtered_ips.extend(best_ips)
                
                if len(ips) > max_per_location:
                    print(f"  ğŸ“ {location}: ä¿ç•™æœ€ä¼˜ {max_per_location}/{len(ips)} ä¸ªIP (å»¶è¿Ÿ: {best_ips[0]['avg_latency']:.0f}ms - {best_ips[-1]['avg_latency']:.0f}ms)")
                else:
                    print(f"  ğŸ“ {location}: ä¿ç•™å…¨éƒ¨ {len(ips)} ä¸ªIP")
            
            return filtered_ips

        async def main():
            print("=" * 60)
            print("ğŸš€ å¼€å§‹æµ‹è¯• IP è¿é€šæ€§ï¼ˆå›½å†…å¤–åŒå‘æ£€æµ‹ï¼‰")
            print("=" * 60)
            
            api_urls = load_api_list('api.txt')
            
            if not api_urls:
                print("âŒ æ²¡æœ‰å¯ç”¨çš„ APIï¼Œè¯·æ£€æŸ¥ api.txt æ–‡ä»¶")
                return
            
            all_ips = []
            seen_ips = set()
            
            async with aiohttp.ClientSession() as session:
                print(f"\nğŸ“¥ æ­£åœ¨ä» {len(api_urls)} ä¸ª API è·å– IP åˆ—è¡¨...")
                print("-" * 60)
                
                for idx, api_url in enumerate(api_urls, 1):
                    print(f"[{idx}/{len(api_urls)}] {api_url}")
                    content = await fetch_url(session, api_url)
                    
                    if not content:
                        continue
                    
                    lines = content.split('\n')
                    count_before = len(all_ips)
                    
                    for line in lines:
                        ip_data = parse_ip_line(line)
                        if ip_data and ip_data['ip'] not in seen_ips:
                            seen_ips.add(ip_data['ip'])
                            all_ips.append(ip_data)
                    
                    new_ips = len(all_ips) - count_before
                    if new_ips > 0:
                        print(f"  âœ… æ–°å¢ {new_ips} ä¸ª IP")
                    else:
                        print(f"  âš ï¸  æœªè·å–åˆ°æ–° IP")
                
                print("-" * 60)
                print(f"âœ… å…±æ”¶é›†åˆ° {len(all_ips)} ä¸ªå”¯ä¸€ IP")
                
                if len(all_ips) == 0:
                    print("âŒ æ²¡æœ‰æ”¶é›†åˆ°ä»»ä½• IPï¼Œè¯·æ£€æŸ¥ API æ˜¯å¦æ­£å¸¸")
                    with open('ip.txt', 'w', encoding='utf-8') as f:
                        f.write(f"# æµ‹è¯•æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                        f.write("# æœªæ”¶é›†åˆ°ä»»ä½• IP æ•°æ®\n")
                    return
                
                print("\nğŸ”„ å¼€å§‹æµ‹è¯•è¿é€šæ€§ï¼ˆå›½å†…å¤–åŒå‘æ£€æµ‹ï¼‰...")
                print("=" * 60)
                print("è¯´æ˜: åªä¿ç•™å›½å†…å¤–å‡å¯è®¿é—®ä¸”ä¸‰ç½‘å…¨é€šçš„IP")
                print(f"ç­–ç•¥: æ¯ä¸ªåœ°åŒºä¿ç•™å»¶è¿Ÿæœ€ä½çš„æœ€å¤š {MAX_IPS_PER_LOCATION} ä¸ªIP")
                print("=" * 60)
                
                valid_ips = []
                
                batch_size = 5  # é™ä½å¹¶å‘ï¼Œå› ä¸ºè¦è°ƒç”¨å…¬å…±æµ‹è¯•ç«™ç‚¹
                for i in range(0, len(all_ips), batch_size):
                    batch = all_ips[i:i+batch_size]
                    batch_tasks = [test_ip_connectivity(ip_data, session) for ip_data in batch]
                    results = await asyncio.gather(*batch_tasks)
                    valid_ips.extend([r for r in results if r is not None])
                    
                    progress = min(i + batch_size, len(all_ips))
                    print(f"\n{'='*60}")
                    print(f"ğŸ“Š è¿›åº¦: {progress}/{len(all_ips)} ({progress*100//len(all_ips)}%) | å›½å†…å¤–å‡å¯è®¿é—®: {len(valid_ips)}")
                    print(f"{'='*60}")
                    
                    await asyncio.sleep(2)  # å»¶è¿Ÿï¼Œé¿å…å…¬å…±ç«™ç‚¹é™æµ
            
            print("\n" + "=" * 60)
            print(f"âœ… æµ‹è¯•å®Œæˆï¼")
            print(f"ğŸ“Š æ€»æµ‹è¯•æ•°: {len(all_ips)}")
            print(f"âœ… å›½å†…å¤–å‡å¯è®¿é—®: {len(valid_ips)}")
            print(f"ğŸ“ˆ é€šè¿‡ç‡: {len(valid_ips)*100//len(all_ips) if all_ips else 0}%")
            print("=" * 60)
            
            if valid_ips:
                print(f"\nğŸ¯ å¼€å§‹æŒ‰åœ°åŒºä¼˜é€‰IP (æ¯ä¸ªåœ°åŒºæœ€å¤šä¿ç•™{MAX_IPS_PER_LOCATION}ä¸ª)...")
                print("-" * 60)
                filtered_ips = filter_best_ips_by_location(valid_ips, MAX_IPS_PER_LOCATION)
                print("-" * 60)
                print(f"âœ… ä¼˜é€‰å®Œæˆ: {len(filtered_ips)}/{len(valid_ips)} ä¸ªIP")
            else:
                filtered_ips = []
            
            # å†™å…¥æ–‡ä»¶
            with open('ip.txt', 'w', encoding='utf-8') as f:
                f.write(f"# IP å›½å†…å¤–åŒå‘è¿é€šæ€§æµ‹è¯•ç»“æœ\n")
                f.write(f"# æµ‹è¯•æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"# æ€»æµ‹è¯•æ•°: {len(all_ips)}\n")
                f.write(f"# å›½å†…å¤–å‡å¯è®¿é—®: {len(valid_ips)}\n")
                f.write(f"# ä¼˜é€‰ä¿ç•™: {len(filtered_ips)}\n")
                f.write(f"# é€šè¿‡ç‡: {len(valid_ips)*100//len(all_ips) if all_ips else 0}%\n")
                f.write(f"# å›½å¤–: GitHub ActionsèŠ‚ç‚¹ âœ“\n")
                f.write(f"# å›½å†…: å…¬å…±æµ‹è¯•ç«™ç‚¹éªŒè¯ âœ“\n")
                f.write(f"# è¿è¥å•†: ä¸­å›½ç”µä¿¡ âœ“ | ä¸­å›½è”é€š âœ“ | ä¸­å›½ç§»åŠ¨ âœ“\n")
                f.write(f"# ä¼˜é€‰ç­–ç•¥: æ¯ä¸ªåœ°åŒºä¿ç•™å»¶è¿Ÿæœ€ä½çš„æœ€å¤š {MAX_IPS_PER_LOCATION} ä¸ªIP\n")
                f.write(f"# æ ¼å¼: IP:ç«¯å£#å›½å®¶-åœ°åŒº\n")
                f.write("#" + "=" * 58 + "\n\n")
                
                if filtered_ips:
                    by_location = {}
                    for ip_info in filtered_ips:
                        location = ip_info['location']
                        if location not in by_location:
                            by_location[location] = []
                        by_location[location].append(ip_info)
                    
                    sorted_locations = sorted(by_location.keys(), key=lambda x: (
                        x.split('-')[0],
                        x.split('-')[1] if '-' in x and len(x.split('-')) > 1 else ''
                    ))
                    
                    for location in sorted_locations:
                        ips = by_location[location]
                        f.write(f"# {location} ({len(ips)}ä¸ª)\n")
                        
                        sorted_ips = sorted(ips, key=lambda x: x['avg_latency'])
                        
                        for ip_info in sorted_ips:
                            line = f"{ip_info['ip']}:{ip_info['port']}#{ip_info['location']}"
                            f.write(f"{line}\n")
                        f.write("\n")
                    
                    print(f"\nğŸ’¾ ç»“æœå·²ä¿å­˜åˆ° ip.txt")
                    
                    # ç»Ÿè®¡ä¿¡æ¯
                    print("\nğŸ“Š åœ°ç†ä½ç½®åˆ†å¸ƒç»Ÿè®¡:")
                    country_stats = {}
                    for location, ips in by_location.items():
                        country = location.split('-')[0]
                        if country not in country_stats:
                            country_stats[country] = {'count': 0, 'latencies': []}
                        country_stats[country]['count'] += len(ips)
                        for ip in ips:
                            country_stats[country]['latencies'].append(ip['avg_latency'])
                    
                    for country, stats in sorted(country_stats.items(), key=lambda x: x[1]['count'], reverse=True):
                        avg_latency = sum(stats['latencies']) / len(stats['latencies'])
                        print(f"  ğŸŒ {country}: {stats['count']} ä¸ª (å¹³å‡å»¶è¿Ÿ: {avg_latency:.0f}ms)")
                    
                    all_latencies = [ip['avg_latency'] for ip in filtered_ips]
                    print("\nâ±ï¸  å»¶è¿Ÿç»Ÿè®¡:")
                    print(f"  ğŸ† æœ€ä½å»¶è¿Ÿ: {min(all_latencies):.0f}ms")
                    print(f"  ğŸ“Š å¹³å‡å»¶è¿Ÿ: {sum(all_latencies)/len(all_latencies):.0f}ms")
                    print(f"  ğŸ“ˆ æœ€é«˜å»¶è¿Ÿ: {max(all_latencies):.0f}ms")
                    
                else:
                    f.write("# æœªæ‰¾åˆ°å›½å†…å¤–å‡å¯è®¿é—®çš„ IP\n")
                    print("\nâš ï¸  æ²¡æœ‰æ‰¾åˆ°å›½å†…å¤–å‡å¯è®¿é—®çš„ IP")

        if __name__ == '__main__':
            asyncio.run(main())
        EOF

    - name: Run IP connectivity test
      run: |
        python test_ip.py

    - name: Check if ip.txt exists and has valid data
      id: check_file
      run: |
        if [ -f ip.txt ]; then
          valid_lines=$(grep -v '^#' ip.txt | grep -E '^\s*[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' | wc -l)
          
          if [ "$valid_lines" -gt 0 ]; then
            echo "file_exists=true" >> $GITHUB_OUTPUT
            echo "âœ… ip.txt æ–‡ä»¶å·²ç”Ÿæˆï¼ŒåŒ…å« $valid_lines ä¸ªæœ‰æ•ˆ IP"
            echo "ip_count=$valid_lines" >> $GITHUB_OUTPUT
          else
            echo "file_exists=false" >> $GITHUB_OUTPUT
            echo "âš ï¸  ip.txt æ–‡ä»¶å·²ç”Ÿæˆï¼Œä½†æ²¡æœ‰æœ‰æ•ˆçš„ IP æ•°æ®"
            echo "ip_count=0" >> $GITHUB_OUTPUT
          fi
          
          echo "ğŸ“„ æ–‡ä»¶å†…å®¹é¢„è§ˆ:"
          head -n 30 ip.txt
        else
          echo "file_exists=false" >> $GITHUB_OUTPUT
          echo "ip_count=0" >> $GITHUB_OUTPUT
          echo "âŒ ip.txt æ–‡ä»¶æœªç”Ÿæˆ"
        fi

    - name: Create Release
      if: steps.check_file.outputs.file_exists == 'true'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ github.run_number }}-${{ github.run_id }}
        name: IP List ${{ github.run_number }} - ${{ steps.check_file.outputs.ip_count }} IPs (å›½å†…å¤–å‡å¯è®¿é—®)
        body: |
          ## ğŸ“‹ IP å›½å†…å¤–åŒå‘è¿é€šæ€§æµ‹è¯•ç»“æœ
          
          **æµ‹è¯•æ—¶é—´:** `${{ github.event.repository.updated_at }}`  
          **è¿è¡Œç¼–å·:** #${{ github.run_number }}  
          **ä¼˜é€‰ IP:** ${{ steps.check_file.outputs.ip_count }} ä¸ª
          
          ### ğŸ“Š æµ‹è¯•è¯´æ˜
          - âœ… æ‰€æœ‰ IP å‡é€šè¿‡å›½å†…å¤–åŒå‘è¿é€šæ€§æµ‹è¯•
          - ğŸŒ **å›½å¤–èŠ‚ç‚¹**: GitHub Actions âœ“
          - ğŸ‡¨ğŸ‡³ **å›½å†…éªŒè¯**: å…¬å…±æµ‹è¯•ç«™ç‚¹ âœ“
          - ğŸŒ **ä¸‰ç½‘æµ‹è¯•**: ä¸­å›½ç”µä¿¡ âœ“ | ä¸­å›½è”é€š âœ“ | ä¸­å›½ç§»åŠ¨ âœ“
          - â±ï¸ åŸºäºå»¶è¿Ÿæµ‹è¯•è¿›è¡Œæ™ºèƒ½ä¼˜é€‰
          - ğŸ“ åŒ…å«è¯¦ç»†åœ°ç†ä½ç½®ä¿¡æ¯ï¼ˆå›½å®¶-åŸå¸‚/åœ°åŒºï¼‰
          - ğŸ¯ **æ™ºèƒ½ä¼˜é€‰**: æ¯ä¸ªåœ°åŒºä¿ç•™å»¶è¿Ÿæœ€ä½çš„æœ€å¤š5ä¸ªIP
          - ğŸ“ æ ¼å¼: `IP:ç«¯å£#å›½å®¶-åœ°åŒº`
          - ğŸ”„ æ¯å¤©åŒ—äº¬æ—¶é—´å‡Œæ™¨ 3 ç‚¹è‡ªåŠ¨æ›´æ–°
          
          ### ğŸ¯ è´¨é‡ä¿è¯
          - **å›½å¤–å¯è®¿é—®**: é€šè¿‡GitHub ActionsèŠ‚ç‚¹éªŒè¯
          - **å›½å†…å¯è®¿é—®**: é€šè¿‡å…¬å…±æµ‹è¯•ç«™ç‚¹éªŒè¯ï¼ˆç«™é•¿å·¥å…·ç­‰ï¼‰
          - **ä¸‰ç½‘å…¨é€š**: ç”µä¿¡ã€è”é€šã€ç§»åŠ¨å‡å¯è¿æ¥
          - **å»¶è¿Ÿä¼˜é€‰**: æŒ‰åœ°åŒºä¿ç•™æœ€ä¼˜IP
          - **è‡ªåŠ¨è¿‡æ»¤**: æ’é™¤è¢«GFWå°é”çš„IP
          
          ### ğŸš« GFWæ£€æµ‹
          æœ¬æµ‹è¯•é‡‡ç”¨å›½å†…å¤–åŒå‘æ£€æµ‹æœºåˆ¶ï¼š
          - å¦‚æœIPåœ¨å›½å¤–å¯è®¿é—®ä½†å›½å†…ä¸é€š â†’ è‡ªåŠ¨æ’é™¤ï¼ˆç–‘ä¼¼è¢«å¢™ï¼‰
          - åªä¿ç•™å›½å†…å¤–å‡å¯è®¿é—®çš„IP
          - ç¡®ä¿å…¨çƒç”¨æˆ·éƒ½èƒ½æ­£å¸¸ä½¿ç”¨
          
          ### ğŸ“¥ ä½¿ç”¨æ–¹æ³•
          1. ä¸‹è½½ `ip.txt` æ–‡ä»¶
          2. æŒ‰ç…§æ ¼å¼ä½¿ç”¨å…¶ä¸­çš„ IP åœ°å€
          3. æ¯ä¸ª IP éƒ½å·²éªŒè¯å›½å†…å¤–å‡å¯è¿æ¥
          4. IPå·²æŒ‰å»¶è¿Ÿæ’åºï¼Œä¼˜å…ˆä½¿ç”¨åˆ—è¡¨å‰é¢çš„IP
          
          ### âš™ï¸ API æ¥æº
          IP æ•°æ®æ¥è‡ª `api.txt` æ–‡ä»¶ä¸­é…ç½®çš„ API æ¥å£
          
          ---
          *æ­¤ Release ç”± GitHub Actions è‡ªåŠ¨ç”Ÿæˆ ğŸ¤–*
        files: |
          ip.txt
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Keep only latest 5 releases
      if: steps.check_file.outputs.file_exists == 'true'
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const releases = await github.rest.repos.listReleases({
            owner: context.repo.owner,
            repo: context.repo.repo,
            per_page: 100
          });
          
          const sortedReleases = releases.data.sort((a, b) => 
            new Date(b.created_at) - new Date(a.created_at)
          );
          
          console.log(`Found ${sortedReleases.length} releases`);
          
          if (sortedReleases.length > 5) {
            for (let i = 5; i < sortedReleases.length; i++) {
              console.log(`Deleting release: ${sortedReleases[i].name} (${sortedReleases[i].tag_name})`);
              await github.rest.repos.deleteRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: sortedReleases[i].id
              });
              
              try {
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `tags/${sortedReleases[i].tag_name}`
                });
                console.log(`Deleted tag: ${sortedReleases[i].tag_name}`);
              } catch (error) {
                console.log(`Could not delete tag: ${sortedReleases[i].tag_name}`);
              }
            }
            console.log(`âœ… Cleaned up ${sortedReleases.length - 5} old releases`);
          } else {
            console.log('âœ… No cleanup needed');
          }
