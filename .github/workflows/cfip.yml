name: Test IP Connectivity and Create Release (Improved China Test)

on:
  schedule:
    - cron: '0 19 * * *'  # 每天北京时间凌晨3点运行
  workflow_dispatch:  # 允许手动触发
  push:
    branches:
      - main
    paths:
      - '.github/workflows/ip-test.yml'
      - 'api.txt'

permissions:
  contents: write
  actions: read

jobs:
  test-and-release:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        pip install requests aiohttp asyncio beautifulsoup4 lxml

    - name: Verify api.txt exists
      run: |
        if [ ! -f api.txt ]; then
          echo "❌ api.txt 文件不存在，正在创建示例文件..."
          cat > api.txt << 'APIEOF'
        # API 列表配置文件
        # CloudFlare IP 优选 API
        https://raw.githubusercontent.com/ymyuuu/IPDB/refs/heads/main/bestproxy.txt
        https://raw.githubusercontent.com/ymyuuu/IPDB/refs/heads/main/bestcf.txt
        https://ip.164746.xyz/ipTop10.html
        https://raw.githubusercontent.com/ZhiXuanWang/cf-speed-dns/refs/heads/main/ipTop10.html
        https://vps789.com/public/sum/cfIpApi
        https://raw.githubusercontent.com/cmliu/WorkerVless2sub/main/addressesapi.txt
        https://addressesapi.090227.xyz/CloudFlareYes
        https://addressesapi.090227.xyz/ip.164746.xyz
        APIEOF
          echo "✅ 已创建示例 api.txt 文件"
        fi
        echo "📋 API 列表内容："
        cat api.txt

    - name: Create improved test script
      run: |
        cat > test_ip_improved.py << 'EOF'
        import asyncio
        import aiohttp
        import json
        import re
        import socket
        from datetime import datetime
        from typing import List, Dict, Optional, Tuple
        import time
        import os
        from bs4 import BeautifulSoup

        # 配置参数
        MAX_IPS_PER_LOCATION = 5  # 每个地区保留的最大IP数量
        TEST_DELAY = 3  # 每个IP测试间隔（秒），避免触发API限制
        BATCH_SIZE = 3  # 批量测试数量

        # 国家代码映射
        COUNTRY_MAPPING = {
            'CN': '中国', 'HK': '香港', 'TW': '台湾', 'JP': '日本', 'KR': '韩国',
            'SG': '新加坡', 'MY': '马来西亚', 'TH': '泰国', 'VN': '越南', 'ID': '印尼',
            'IN': '印度', 'PH': '菲律宾', 'US': '美国', 'CA': '加拿大', 'MX': '墨西哥',
            'DE': '德国', 'GB': '英国', 'FR': '法国', 'IT': '意大利', 'ES': '西班牙',
            'PT': '葡萄牙', 'NL': '荷兰', 'BE': '比利时', 'SE': '瑞典', 'NO': '挪威',
            'AU': '澳大利亚', 'NZ': '新西兰', 'BR': '巴西', 'AR': '阿根廷', 'RU': '俄罗斯',
        }

        def load_api_list(filename: str = 'api.txt') -> List[str]:
            """从 api.txt 加载 API 列表"""
            api_urls = []
            if not os.path.exists(filename):
                print(f"❌ {filename} 文件不存在")
                return api_urls
            
            with open(filename, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        api_urls.append(line)
            
            print(f"✅ 从 {filename} 加载了 {len(api_urls)} 个 API")
            return api_urls

        def is_valid_ip(ip: str) -> bool:
            """验证IP地址格式"""
            parts = ip.split('.')
            if len(parts) != 4:
                return False
            for part in parts:
                try:
                    num = int(part)
                    if num < 0 or num > 255:
                        return False
                    if len(part) > 1 and part[0] == '0':
                        return False
                except ValueError:
                    return False
            return True

        def is_valid_port(port: str) -> bool:
            """验证端口号格式"""
            try:
                num = int(port)
                return 0 < num <= 65535
            except ValueError:
                return False

        def parse_ip_line(line: str) -> Optional[Dict]:
            """解析IP行，支持多种格式"""
            line = line.strip()
            if not line or line.startswith(('#', '//', '<!--', 'http')):
                return None
            
            # IP:Port#Country
            match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)#(.+)$', line)
            if match:
                ip, port, country = match.groups()
                if is_valid_ip(ip) and is_valid_port(port):
                    return {'ip': ip, 'port': port, 'country': country.strip()}
            
            # IP#Country
            match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})#(.+)$', line)
            if match:
                ip, country = match.groups()
                if is_valid_ip(ip):
                    return {'ip': ip, 'port': '443', 'country': country.strip()}
            
            # IP:Port
            match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)', line)
            if match:
                ip, port = match.groups()
                if is_valid_ip(ip) and is_valid_port(port):
                    return {'ip': ip, 'port': port, 'country': None}
            
            # 单独IP
            match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})$', line)
            if match:
                ip = match.group(1)
                if is_valid_ip(ip):
                    return {'ip': ip, 'port': '443', 'country': None}
            
            return None

        async def fetch_url(session: aiohttp.ClientSession, url: str) -> str:
            """异步获取URL内容"""
            try:
                async with session.get(url, timeout=aiohttp.ClientTimeout(total=30)) as response:
                    if response.status == 200:
                        return await response.text()
                    else:
                        print(f"⚠️  {url} 返回状态码: {response.status}")
            except asyncio.TimeoutError:
                print(f"⏱️  {url} 请求超时")
            except Exception as e:
                print(f"❌ 获取 {url} 失败: {e}")
            return ""

        async def get_ip_location(session: aiohttp.ClientSession, ip: str, retry: int = 2) -> str:
            """获取IP详细地理位置"""
            for attempt in range(retry):
                try:
                    async with session.get(
                        f'http://ip-api.com/json/{ip}?lang=zh-CN&fields=status,country,regionName,city,countryCode',
                        timeout=aiohttp.ClientTimeout(total=10)
                    ) as response:
                        if response.status == 200:
                            data = await response.json()
                            if data.get('status') == 'success':
                                country = data.get('country', '')
                                city = data.get('city', '')
                                country_code = data.get('countryCode', '')
                                
                                if country_code and country_code in COUNTRY_MAPPING:
                                    country = COUNTRY_MAPPING[country_code]
                                
                                location_parts = [country] if country else []
                                if city and city.strip():
                                    location_parts.append(city.strip())
                                
                                if location_parts:
                                    return '-'.join(location_parts)
                except Exception as e:
                    if attempt == retry - 1:
                        print(f"        ⚠️  地理位置查询失败: {e}")
                    await asyncio.sleep(1)
            
            return 'Unknown'

        def test_overseas_connectivity(ip: str, port: int, timeout: float = 5.0) -> Tuple[bool, Optional[float]]:
            """测试国外连通性（GitHub Actions环境）"""
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                
                start_time = time.time()
                result = sock.connect_ex((ip, port))
                end_time = time.time()
                
                sock.close()
                
                if result == 0:
                    latency = round((end_time - start_time) * 1000, 2)
                    return True, latency
                else:
                    return False, None
            except Exception:
                return False, None

        class ChinaNetworkTester:
            """国内三网连通性测试器（使用公共API）"""
            
            async def test_via_ipcheck(self, session: aiohttp.ClientSession, ip: str) -> Optional[Dict]:
                """
                通过 IPCheck API 测试
                API: https://ipcheck.need.sh/ 或 https://ipcheck.ing/
                """
                try:
                    # 尝试主API
                    urls = [
                        f"https://api.ipcheck.ing/api/ping/{ip}",
                        f"https://ipcheck.need.sh/api/ping/{ip}"
                    ]
                    
                    for url in urls:
                        try:
                            headers = {
                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                            }
                            
                            async with session.get(url, headers=headers, timeout=aiohttp.ClientTimeout(total=25)) as response:
                                if response.status == 200:
                                    data = await response.json()
                                    
                                    results = {'电信': False, '联通': False, '移动': False}
                                    
                                    if data.get('code') == 200 and data.get('data'):
                                        for item in data['data']:
                                            isp = item.get('isp', '')
                                            avg_latency = item.get('avg', 9999)
                                            
                                            # 延迟小于800ms认为可用
                                            if avg_latency > 0 and avg_latency < 800:
                                                if '电信' in isp or 'CT' in isp:
                                                    results['电信'] = True
                                                elif '联通' in isp or 'CU' in isp:
                                                    results['联通'] = True
                                                elif '移动' in isp or 'CM' in isp:
                                                    results['移动'] = True
                                    
                                    # 如果至少有一个运营商可用，返回结果
                                    if any(results.values()):
                                        return results
                        except:
                            continue
                    
                    return None
                    
                except Exception as e:
                    print(f"        IPCheck 测试异常: {e}")
                    return None
            
            async def test_via_chinaz(self, session: aiohttp.ClientSession, ip: str) -> Optional[Dict]:
                """通过站长工具测试"""
                try:
                    url = f"https://ping.chinaz.com/{ip}"
                    headers = {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                    }
                    
                    async with session.get(url, headers=headers, timeout=aiohttp.ClientTimeout(total=30)) as response:
                        if response.status != 200:
                            return None
                        
                        html = await response.text()
                        
                        # 统计成功的Ping次数
                        success_count = html.count('ms</span>') - html.count('超时')
                        
                        results = {'电信': False, '联通': False, '移动': False}
                        
                        # 如果成功响应数量足够，认为可用
                        if success_count >= 5:
                            # 尝试识别运营商
                            if '电信' in html:
                                results['电信'] = True
                            if '联通' in html:
                                results['联通'] = True
                            if '移动' in html:
                                results['移动'] = True
                            
                            # 如果无法识别具体运营商，但有足够成功数，认为都可用
                            if not any(results.values()):
                                results = {'电信': True, '联通': True, '移动': True}
                        
                        return results if any(results.values()) else None
                        
                except Exception as e:
                    print(f"        站长工具测试异常: {e}")
                    return None
            
            async def test_china_connectivity(self, session: aiohttp.ClientSession, ip: str) -> Optional[Dict]:
                """综合测试国内三网连通性"""
                print(f"      🇨🇳 国内三网测试:")
                
                all_results = []
                
                # 1. 优先使用 IPCheck（最准确）
                print(f"        [1/2] IPCheck API...", end=' ')
                ipcheck_result = await self.test_via_ipcheck(session, ip)
                if ipcheck_result:
                    all_results.append(ipcheck_result)
                    print("✅")
                else:
                    print("❌")
                
                await asyncio.sleep(1)
                
                # 2. 备用站长工具
                print(f"        [2/2] 站长工具...", end=' ')
                chinaz_result = await self.test_via_chinaz(session, ip)
                if chinaz_result:
                    all_results.append(chinaz_result)
                    print("✅")
                else:
                    print("❌")
                
                if not all_results:
                    print(f"        ⚠️  所有测试源均失败")
                    return None
                
                # 综合判断：多数源认可才算通过
                final_result = {
                    '电信': sum(r.get('电信', False) for r in all_results) >= len(all_results) // 2,
                    '联通': sum(r.get('联通', False) for r in all_results) >= len(all_results) // 2,
                    '移动': sum(r.get('移动', False) for r in all_results) >= len(all_results) // 2,
                }
                
                # 打印结果
                for isp, connected in final_result.items():
                    status = "✅" if connected else "❌"
                    print(f"        {status} {isp}")
                
                # 至少两个运营商可用
                connected_count = sum(final_result.values())
                final_result['reliable'] = connected_count >= 2
                final_result['connected_count'] = connected_count
                
                return final_result

        async def test_ip_connectivity(ip_data: Dict, session: aiohttp.ClientSession, 
                                      tester: ChinaNetworkTester) -> Optional[Dict]:
            """测试单个IP的连通性"""
            ip = ip_data['ip']
            port = int(ip_data['port'])
            
            print(f"\n{'='*60}")
            print(f"🔍 测试 IP: {ip}:{port}")
            print(f"{'='*60}")
            
            # 1. 国外连通性测试
            print(f"    [1/3] 🌍 国外连通性...", end=' ')
            overseas_connected, overseas_latency = test_overseas_connectivity(ip, port)
            
            if not overseas_connected:
                print("❌ 不通")
                return None
            
            print(f"✅ 通 ({overseas_latency:.0f}ms)")
            
            # 2. 国内三网真实测试
            print(f"    [2/3] 国内三网真实连通性测试:")
            china_result = await tester.test_china_connectivity(session, ip)
            
            if not china_result:
                print(f"        🚫 测试失败，跳过")
                return None
            
            if not china_result['reliable']:
                print(f"        🚫 国内连通性不可靠（仅{china_result['connected_count']}/3运营商可用）")
                return None
            
            # 3. 查询地理位置
            print(f"    [3/3] 地理位置...", end=' ')
            location = await get_ip_location(session, ip, retry=2)
            
            if location == 'Unknown' or '-' not in location:
                print(f"❌ 无效")
                return None
            
            print(f"✅ {location}")
            print(f"    🎉 通过所有测试！")
            
            return {
                'ip': ip,
                'port': port,
                'location': location,
                'china_result': china_result,
                'overseas_latency': overseas_latency,
            }

        def filter_best_ips_by_location(valid_ips: List[Dict], max_per_location: int = MAX_IPS_PER_LOCATION) -> List[Dict]:
            """按地理位置分组，保留每个地区延迟最低的IP"""
            by_location = {}
            for ip_info in valid_ips:
                location = ip_info['location']
                if location not in by_location:
                    by_location[location] = []
                by_location[location].append(ip_info)
            
            filtered_ips = []
            for location, ips in by_location.items():
                sorted_ips = sorted(ips, key=lambda x: x['overseas_latency'])
                best_ips = sorted_ips[:max_per_location]
                filtered_ips.extend(best_ips)
                
                if len(ips) > max_per_location:
                    print(f"  📍 {location}: 保留 {max_per_location}/{len(ips)} 个IP")
                else:
                    print(f"  📍 {location}: 保留全部 {len(ips)} 个IP")
            
            return filtered_ips

        async def main():
            print("=" * 60)
            print("🚀 IP 连通性测试 - 改进版（真实国内网络测试）")
            print("=" * 60)
            
            api_urls = load_api_list('api.txt')
            
            if not api_urls:
                print("❌ 没有可用的 API")
                return
            
            all_ips = []
            seen_ips = set()
            
            async with aiohttp.ClientSession() as session:
                print(f"\n📥 从 {len(api_urls)} 个 API 获取 IP...")
                print("-" * 60)
                
                for idx, api_url in enumerate(api_urls, 1):
                    print(f"[{idx}/{len(api_urls)}] {api_url}")
                    content = await fetch_url(session, api_url)
                    
                    if not content:
                        continue
                    
                    count_before = len(all_ips)
                    for line in content.split('\n'):
                        ip_data = parse_ip_line(line)
                        if ip_data and ip_data['ip'] not in seen_ips:
                            seen_ips.add(ip_data['ip'])
                            all_ips.append(ip_data)
                    
                    new_ips = len(all_ips) - count_before
                    print(f"  {'✅' if new_ips > 0 else '⚠️'} 新增 {new_ips} 个IP")
                
                print("-" * 60)
                print(f"✅ 共收集 {len(all_ips)} 个唯一IP")
                
                if len(all_ips) == 0:
                    with open('ip.txt', 'w', encoding='utf-8') as f:
                        f.write(f"# 测试时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                        f.write("# 未收集到任何 IP 数据\n")
                    return
                
                print("\n🔄 开始连通性测试...")
                print("=" * 60)
                print("✓ 国外: GitHub Actions节点")
                print("✓ 国内: IPCheck + 站长工具（真实网络测试）")
                print("✓ 三网: 中国电信 | 中国联通 | 中国移动")
                print(f"✓ 优选: 每地区最多保留{MAX_IPS_PER_LOCATION}个")
                print("=" * 60)
                
                tester = ChinaNetworkTester()
                valid_ips = []
                
                for i in range(0, len(all_ips), BATCH_SIZE):
                    batch = all_ips[i:i+BATCH_SIZE]
                    batch_tasks = [test_ip_connectivity(ip_data, session, tester) for ip_data in batch]
                    results = await asyncio.gather(*batch_tasks)
                    valid_ips.extend([r for r in results if r is not None])
                    
                    progress = min(i + BATCH_SIZE, len(all_ips))
                    print(f"\n{'='*60}")
                    print(f"📊 进度: {progress}/{len(all_ips)} ({progress*100//len(all_ips)}%) | 通过: {len(valid_ips)}")
                    print(f"{'='*60}")
                    
                    await asyncio.sleep(TEST_DELAY)
            
            print("\n" + "=" * 60)
            print(f"✅ 测试完成")
            print(f"📊 总数: {len(all_ips)} | 通过: {len(valid_ips)} | 通过率: {len(valid_ips)*100//len(all_ips) if all_ips else 0}%")
            print("=" * 60)
            
            if valid_ips:
                print(f"\n🎯 按地区优选IP...")
                print("-" * 60)
                filtered_ips = filter_best_ips_by_location(valid_ips, MAX_IPS_PER_LOCATION)
                print("-" * 60)
                print(f"✅ 最终: {len(filtered_ips)} 个IP")
            else:
                filtered_ips = []
            
            # 写入文件
            with open('ip.txt', 'w', encoding='utf-8') as f:
                f.write(f"# IP 连通性测试结果（改进版 - 真实国内网络测试）\n")
                f.write(f"# 测试时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"# 总测试: {len(all_ips)} | 通过: {len(valid_ips)} | 优选: {len(filtered_ips)}\n")
                f.write(f"# 通过率: {len(valid_ips)*100//len(all_ips) if all_ips else 0}%\n")
                f.write(f"# 国外测试: GitHub Actions ✓\n")
                f.write(f"# 国内测试: IPCheck API ✓ | 站长工具 ✓\n")
                f.write(f"# 三网要求: 至少2/3运营商可用\n")
                f.write(f"# 优选策略: 每地区最多{MAX_IPS_PER_LOCATION}个（按延迟排序）\n")
                f.write(f"# 格式: IP:端口#国家-地区\n")
                f.write("#" + "=" * 58 + "\n\n")
                
                if filtered_ips:
                    by_location = {}
                    for ip_info in filtered_ips:
                        location = ip_info['location']
                        if location not in by_location:
                            by_location[location] = []
                        by_location[location].append(ip_info)
                    
                    sorted_locations = sorted(by_location.keys())
                    
                    for location in sorted_locations:
                        ips = by_location[location]
                        f.write(f"# {location} ({len(ips)}个)\n")
                        
                        sorted_ips = sorted(ips, key=lambda x: x['overseas_latency'])
                        
                        for ip_info in sorted_ips:
                            line = f"{ip_info['ip']}:{ip_info['port']}#{ip_info['location']}"
                            f.write(f"{line}\n")
                        f.write("\n")
                    
                    print(f"\n💾 结果已保存到 ip.txt")
                    
                    # 统计
                    print("\n📊 统计信息:")
                    country_stats = {}
                    for location, ips in by_location.items():
                        country = location.split('-')[0]
                        if country not in country_stats:
                            country_stats[country] = 0
                        country_stats[country] += len(ips)
                    
                    for country, count in sorted(country_stats.items(), key=lambda x: x[1], reverse=True):
                        print(f"  🌍 {country}: {count} 个")
                else:
                    f.write("# 未找到符合条件的 IP\n")
                    print("\n⚠️ 没有找到符合条件的IP")

        if __name__ == '__main__':
            asyncio.run(main())
        EOF

    - name: Run IP connectivity test (Improved)
      run: |
        python test_ip_improved.py

    - name: Check if ip.txt exists and has valid data
      id: check_file
      run: |
        if [ -f ip.txt ]; then
          valid_lines=$(grep -v '^#' ip.txt | grep -E '^\s*[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' | wc -l)
          
          if [ "$valid_lines" -gt 0 ]; then
            echo "file_exists=true" >> $GITHUB_OUTPUT
            echo "✅ ip.txt 已生成，包含 $valid_lines 个有效IP"
            echo "ip_count=$valid_lines" >> $GITHUB_OUTPUT
          else
            echo "file_exists=false" >> $GITHUB_OUTPUT
            echo "⚠️ ip.txt 已生成，但无有效IP"
            echo "ip_count=0" >> $GITHUB_OUTPUT
          fi
          
          echo "📄 文件预览:"
          head -n 30 ip.txt
        else
          echo "file_exists=false" >> $GITHUB_OUTPUT
          echo "ip_count=0" >> $GITHUB_OUTPUT
          echo "❌ ip.txt 未生成"
        fi

    - name: Create Release
      if: steps.check_file.outputs.file_exists == 'true'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ github.run_number }}-${{ github.run_id }}
        name: IP List v${{ github.run_number }} - ${{ steps.check_file.outputs.ip_count }} IPs (真实国内三网测试)
        body: |
          ## 📋 IP 连通性测试结果（改进版）
          
          **测试时间:** `${{ github.event.repository.updated_at }}`  
          **运行编号:** #${{ github.run_number }}  
          **优选 IP:** ${{ steps.check_file.outputs.ip_count }} 个
          
          ### 🎯 测试方法（真实国内网络测试）
          
          #### ✅ 国外测试
          - 通过 GitHub Actions 节点直接连接测试
          
          #### ✅ 国内测试（真实网络环境）
          - **IPCheck API**: 专业IP连通性测试服务，提供三网分测数据
          - **站长工具**: 多地区多运营商节点验证
          - **双源交叉验证**: 只有多数测试源都通过才认定为可用
          
          #### 🌐 三网要求
          - 中国电信 ✓
          - 中国联通 ✓  
          - 中国移动 ✓
          - **至少 2/3 运营商可用才通过**
          
          #### 🎯 智能优选策略
          - 按地理位置分组
          - 每个地区保留延迟最低的最多 5 个 IP
          - 自动过滤被墙 IP
          - 包含详细地理位置信息
          
          ### 📝 文件格式
          ```
          IP:端口#国家-地区
          ```
          
          ### 🚫 GFW 检测机制
          - 国外可访问 + 国内不通 → 自动排除
          - 只保留国内外均可访问的 IP
          - 确保全球用户都能正常使用
          
          ### 📥 使用方法
          1. 下载 `ip.txt` 文件
          2. 每个 IP 都已通过真实国内网络验证
          3. IP 按延迟排序，优先使用前面的
          4. 每天自动更新（北京时间凌晨 3 点）
          
          ### ⚙️ 数据来源
          IP 来源于 `api.txt` 中配置的 CloudFlare IP 优选 API
          
          ### 🔄 更新频率
          - 自动: 每天北京时间凌晨 3 点
          - 手动: 可随时在 Actions 页面手动触发
          
          ---
          *此 Release 由 GitHub Actions 自动生成 | 使用真实国内网络测试 🤖*
        files: |
          ip.txt
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Keep only latest 5 releases
      if: steps.check_file.outputs.file_exists == 'true'
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const releases = await github.rest.repos.listReleases({
            owner: context.repo.owner,
            repo: context.repo.repo,
            per_page: 100
          });
          
          const sortedReleases = releases.data.sort((a, b) => 
            new Date(b.created_at) - new Date(a.created_at)
          );
          
          console.log(`Found ${sortedReleases.length} releases`);
          
          if (sortedReleases.length > 5) {
            for (let i = 5; i < sortedReleases.length; i++) {
              console.log(`Deleting: ${sortedReleases[i].name}`);
              await github.rest.repos.deleteRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: sortedReleases[i].id
              });
              
              try {
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `tags/${sortedReleases[i].tag_name}`
                });
              } catch (error) {
                console.log(`Tag deletion failed: ${sortedReleases[i].tag_name}`);
              }
            }
            console.log(`✅ Cleaned ${sortedReleases.length - 5} old releases`);
          } else {
            console.log('✅ No cleanup needed');
          }
