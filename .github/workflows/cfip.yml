name: Test IP Connectivity and Create Release (Improved China Test)

on:
  schedule:
    - cron: '0 19 * * *'  # æ¯å¤©åŒ—äº¬æ—¶é—´å‡Œæ™¨3ç‚¹è¿è¡Œ
  workflow_dispatch:  # å…è®¸æ‰‹åŠ¨è§¦å‘
  push:
    branches:
      - main
    paths:
      - '.github/workflows/ip-test.yml'
      - 'api.txt'

permissions:
  contents: write
  actions: read

jobs:
  test-and-release:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        pip install requests aiohttp asyncio beautifulsoup4 lxml

    - name: Verify api.txt exists
      run: |
        if [ ! -f api.txt ]; then
          echo "âŒ api.txt æ–‡ä»¶ä¸å­˜åœ¨ï¼Œæ­£åœ¨åˆ›å»ºç¤ºä¾‹æ–‡ä»¶..."
          cat > api.txt << 'APIEOF'
        # API åˆ—è¡¨é…ç½®æ–‡ä»¶
        # CloudFlare IP ä¼˜é€‰ API
        https://raw.githubusercontent.com/ymyuuu/IPDB/refs/heads/main/bestproxy.txt
        https://raw.githubusercontent.com/ymyuuu/IPDB/refs/heads/main/bestcf.txt
        https://ip.164746.xyz/ipTop10.html
        https://raw.githubusercontent.com/ZhiXuanWang/cf-speed-dns/refs/heads/main/ipTop10.html
        https://vps789.com/public/sum/cfIpApi
        https://raw.githubusercontent.com/cmliu/WorkerVless2sub/main/addressesapi.txt
        https://addressesapi.090227.xyz/CloudFlareYes
        https://addressesapi.090227.xyz/ip.164746.xyz
        APIEOF
          echo "âœ… å·²åˆ›å»ºç¤ºä¾‹ api.txt æ–‡ä»¶"
        fi
        echo "ğŸ“‹ API åˆ—è¡¨å†…å®¹ï¼š"
        cat api.txt

    - name: Create improved test script
      run: |
        cat > test_ip_improved.py << 'EOF'
        import asyncio
        import aiohttp
        import json
        import re
        import socket
        from datetime import datetime
        from typing import List, Dict, Optional, Tuple
        import time
        import os
        from bs4 import BeautifulSoup

        # é…ç½®å‚æ•°
        MAX_IPS_PER_LOCATION = 5  # æ¯ä¸ªåœ°åŒºä¿ç•™çš„æœ€å¤§IPæ•°é‡
        TEST_DELAY = 3  # æ¯ä¸ªIPæµ‹è¯•é—´éš”ï¼ˆç§’ï¼‰ï¼Œé¿å…è§¦å‘APIé™åˆ¶
        BATCH_SIZE = 3  # æ‰¹é‡æµ‹è¯•æ•°é‡

        # å›½å®¶ä»£ç æ˜ å°„
        COUNTRY_MAPPING = {
            'CN': 'ä¸­å›½', 'HK': 'é¦™æ¸¯', 'TW': 'å°æ¹¾', 'JP': 'æ—¥æœ¬', 'KR': 'éŸ©å›½',
            'SG': 'æ–°åŠ å¡', 'MY': 'é©¬æ¥è¥¿äºš', 'TH': 'æ³°å›½', 'VN': 'è¶Šå—', 'ID': 'å°å°¼',
            'IN': 'å°åº¦', 'PH': 'è²å¾‹å®¾', 'US': 'ç¾å›½', 'CA': 'åŠ æ‹¿å¤§', 'MX': 'å¢¨è¥¿å“¥',
            'DE': 'å¾·å›½', 'GB': 'è‹±å›½', 'FR': 'æ³•å›½', 'IT': 'æ„å¤§åˆ©', 'ES': 'è¥¿ç­ç‰™',
            'PT': 'è‘¡è„ç‰™', 'NL': 'è·å…°', 'BE': 'æ¯”åˆ©æ—¶', 'SE': 'ç‘å…¸', 'NO': 'æŒªå¨',
            'AU': 'æ¾³å¤§åˆ©äºš', 'NZ': 'æ–°è¥¿å…°', 'BR': 'å·´è¥¿', 'AR': 'é˜¿æ ¹å»·', 'RU': 'ä¿„ç½—æ–¯',
        }

        def load_api_list(filename: str = 'api.txt') -> List[str]:
            """ä» api.txt åŠ è½½ API åˆ—è¡¨"""
            api_urls = []
            if not os.path.exists(filename):
                print(f"âŒ {filename} æ–‡ä»¶ä¸å­˜åœ¨")
                return api_urls
            
            with open(filename, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        api_urls.append(line)
            
            print(f"âœ… ä» {filename} åŠ è½½äº† {len(api_urls)} ä¸ª API")
            return api_urls

        def is_valid_ip(ip: str) -> bool:
            """éªŒè¯IPåœ°å€æ ¼å¼"""
            parts = ip.split('.')
            if len(parts) != 4:
                return False
            for part in parts:
                try:
                    num = int(part)
                    if num < 0 or num > 255:
                        return False
                    if len(part) > 1 and part[0] == '0':
                        return False
                except ValueError:
                    return False
            return True

        def is_valid_port(port: str) -> bool:
            """éªŒè¯ç«¯å£å·æ ¼å¼"""
            try:
                num = int(port)
                return 0 < num <= 65535
            except ValueError:
                return False

        def parse_ip_line(line: str) -> Optional[Dict]:
            """è§£æIPè¡Œï¼Œæ”¯æŒå¤šç§æ ¼å¼"""
            line = line.strip()
            if not line or line.startswith(('#', '//', '<!--', 'http')):
                return None
            
            # IP:Port#Country
            match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)#(.+)$', line)
            if match:
                ip, port, country = match.groups()
                if is_valid_ip(ip) and is_valid_port(port):
                    return {'ip': ip, 'port': port, 'country': country.strip()}
            
            # IP#Country
            match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})#(.+)$', line)
            if match:
                ip, country = match.groups()
                if is_valid_ip(ip):
                    return {'ip': ip, 'port': '443', 'country': country.strip()}
            
            # IP:Port
            match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)', line)
            if match:
                ip, port = match.groups()
                if is_valid_ip(ip) and is_valid_port(port):
                    return {'ip': ip, 'port': port, 'country': None}
            
            # å•ç‹¬IP
            match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})$', line)
            if match:
                ip = match.group(1)
                if is_valid_ip(ip):
                    return {'ip': ip, 'port': '443', 'country': None}
            
            return None

        async def fetch_url(session: aiohttp.ClientSession, url: str) -> str:
            """å¼‚æ­¥è·å–URLå†…å®¹"""
            try:
                async with session.get(url, timeout=aiohttp.ClientTimeout(total=30)) as response:
                    if response.status == 200:
                        return await response.text()
                    else:
                        print(f"âš ï¸  {url} è¿”å›çŠ¶æ€ç : {response.status}")
            except asyncio.TimeoutError:
                print(f"â±ï¸  {url} è¯·æ±‚è¶…æ—¶")
            except Exception as e:
                print(f"âŒ è·å– {url} å¤±è´¥: {e}")
            return ""

        async def get_ip_location(session: aiohttp.ClientSession, ip: str, retry: int = 2) -> str:
            """è·å–IPè¯¦ç»†åœ°ç†ä½ç½®"""
            for attempt in range(retry):
                try:
                    async with session.get(
                        f'http://ip-api.com/json/{ip}?lang=zh-CN&fields=status,country,regionName,city,countryCode',
                        timeout=aiohttp.ClientTimeout(total=10)
                    ) as response:
                        if response.status == 200:
                            data = await response.json()
                            if data.get('status') == 'success':
                                country = data.get('country', '')
                                city = data.get('city', '')
                                country_code = data.get('countryCode', '')
                                
                                if country_code and country_code in COUNTRY_MAPPING:
                                    country = COUNTRY_MAPPING[country_code]
                                
                                location_parts = [country] if country else []
                                if city and city.strip():
                                    location_parts.append(city.strip())
                                
                                if location_parts:
                                    return '-'.join(location_parts)
                except Exception as e:
                    if attempt == retry - 1:
                        print(f"        âš ï¸  åœ°ç†ä½ç½®æŸ¥è¯¢å¤±è´¥: {e}")
                    await asyncio.sleep(1)
            
            return 'Unknown'

        def test_overseas_connectivity(ip: str, port: int, timeout: float = 5.0) -> Tuple[bool, Optional[float]]:
            """æµ‹è¯•å›½å¤–è¿é€šæ€§ï¼ˆGitHub Actionsç¯å¢ƒï¼‰"""
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                
                start_time = time.time()
                result = sock.connect_ex((ip, port))
                end_time = time.time()
                
                sock.close()
                
                if result == 0:
                    latency = round((end_time - start_time) * 1000, 2)
                    return True, latency
                else:
                    return False, None
            except Exception:
                return False, None

        class ChinaNetworkTester:
            """å›½å†…ä¸‰ç½‘è¿é€šæ€§æµ‹è¯•å™¨ï¼ˆä½¿ç”¨å…¬å…±APIï¼‰"""
            
            async def test_via_ipcheck(self, session: aiohttp.ClientSession, ip: str) -> Optional[Dict]:
                """
                é€šè¿‡ IPCheck API æµ‹è¯•
                API: https://ipcheck.need.sh/ æˆ– https://ipcheck.ing/
                """
                try:
                    # å°è¯•ä¸»API
                    urls = [
                        f"https://api.ipcheck.ing/api/ping/{ip}",
                        f"https://ipcheck.need.sh/api/ping/{ip}"
                    ]
                    
                    for url in urls:
                        try:
                            headers = {
                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                            }
                            
                            async with session.get(url, headers=headers, timeout=aiohttp.ClientTimeout(total=25)) as response:
                                if response.status == 200:
                                    data = await response.json()
                                    
                                    results = {'ç”µä¿¡': False, 'è”é€š': False, 'ç§»åŠ¨': False}
                                    
                                    if data.get('code') == 200 and data.get('data'):
                                        for item in data['data']:
                                            isp = item.get('isp', '')
                                            avg_latency = item.get('avg', 9999)
                                            
                                            # å»¶è¿Ÿå°äº800msè®¤ä¸ºå¯ç”¨
                                            if avg_latency > 0 and avg_latency < 800:
                                                if 'ç”µä¿¡' in isp or 'CT' in isp:
                                                    results['ç”µä¿¡'] = True
                                                elif 'è”é€š' in isp or 'CU' in isp:
                                                    results['è”é€š'] = True
                                                elif 'ç§»åŠ¨' in isp or 'CM' in isp:
                                                    results['ç§»åŠ¨'] = True
                                    
                                    # å¦‚æœè‡³å°‘æœ‰ä¸€ä¸ªè¿è¥å•†å¯ç”¨ï¼Œè¿”å›ç»“æœ
                                    if any(results.values()):
                                        return results
                        except:
                            continue
                    
                    return None
                    
                except Exception as e:
                    print(f"        IPCheck æµ‹è¯•å¼‚å¸¸: {e}")
                    return None
            
            async def test_via_chinaz(self, session: aiohttp.ClientSession, ip: str) -> Optional[Dict]:
                """é€šè¿‡ç«™é•¿å·¥å…·æµ‹è¯•"""
                try:
                    url = f"https://ping.chinaz.com/{ip}"
                    headers = {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                    }
                    
                    async with session.get(url, headers=headers, timeout=aiohttp.ClientTimeout(total=30)) as response:
                        if response.status != 200:
                            return None
                        
                        html = await response.text()
                        
                        # ç»Ÿè®¡æˆåŠŸçš„Pingæ¬¡æ•°
                        success_count = html.count('ms</span>') - html.count('è¶…æ—¶')
                        
                        results = {'ç”µä¿¡': False, 'è”é€š': False, 'ç§»åŠ¨': False}
                        
                        # å¦‚æœæˆåŠŸå“åº”æ•°é‡è¶³å¤Ÿï¼Œè®¤ä¸ºå¯ç”¨
                        if success_count >= 5:
                            # å°è¯•è¯†åˆ«è¿è¥å•†
                            if 'ç”µä¿¡' in html:
                                results['ç”µä¿¡'] = True
                            if 'è”é€š' in html:
                                results['è”é€š'] = True
                            if 'ç§»åŠ¨' in html:
                                results['ç§»åŠ¨'] = True
                            
                            # å¦‚æœæ— æ³•è¯†åˆ«å…·ä½“è¿è¥å•†ï¼Œä½†æœ‰è¶³å¤ŸæˆåŠŸæ•°ï¼Œè®¤ä¸ºéƒ½å¯ç”¨
                            if not any(results.values()):
                                results = {'ç”µä¿¡': True, 'è”é€š': True, 'ç§»åŠ¨': True}
                        
                        return results if any(results.values()) else None
                        
                except Exception as e:
                    print(f"        ç«™é•¿å·¥å…·æµ‹è¯•å¼‚å¸¸: {e}")
                    return None
            
            async def test_china_connectivity(self, session: aiohttp.ClientSession, ip: str) -> Optional[Dict]:
                """ç»¼åˆæµ‹è¯•å›½å†…ä¸‰ç½‘è¿é€šæ€§"""
                print(f"      ğŸ‡¨ğŸ‡³ å›½å†…ä¸‰ç½‘æµ‹è¯•:")
                
                all_results = []
                
                # 1. ä¼˜å…ˆä½¿ç”¨ IPCheckï¼ˆæœ€å‡†ç¡®ï¼‰
                print(f"        [1/2] IPCheck API...", end=' ')
                ipcheck_result = await self.test_via_ipcheck(session, ip)
                if ipcheck_result:
                    all_results.append(ipcheck_result)
                    print("âœ…")
                else:
                    print("âŒ")
                
                await asyncio.sleep(1)
                
                # 2. å¤‡ç”¨ç«™é•¿å·¥å…·
                print(f"        [2/2] ç«™é•¿å·¥å…·...", end=' ')
                chinaz_result = await self.test_via_chinaz(session, ip)
                if chinaz_result:
                    all_results.append(chinaz_result)
                    print("âœ…")
                else:
                    print("âŒ")
                
                if not all_results:
                    print(f"        âš ï¸  æ‰€æœ‰æµ‹è¯•æºå‡å¤±è´¥")
                    return None
                
                # ç»¼åˆåˆ¤æ–­ï¼šå¤šæ•°æºè®¤å¯æ‰ç®—é€šè¿‡
                final_result = {
                    'ç”µä¿¡': sum(r.get('ç”µä¿¡', False) for r in all_results) >= len(all_results) // 2,
                    'è”é€š': sum(r.get('è”é€š', False) for r in all_results) >= len(all_results) // 2,
                    'ç§»åŠ¨': sum(r.get('ç§»åŠ¨', False) for r in all_results) >= len(all_results) // 2,
                }
                
                # æ‰“å°ç»“æœ
                for isp, connected in final_result.items():
                    status = "âœ…" if connected else "âŒ"
                    print(f"        {status} {isp}")
                
                # è‡³å°‘ä¸¤ä¸ªè¿è¥å•†å¯ç”¨
                connected_count = sum(final_result.values())
                final_result['reliable'] = connected_count >= 2
                final_result['connected_count'] = connected_count
                
                return final_result

        async def test_ip_connectivity(ip_data: Dict, session: aiohttp.ClientSession, 
                                      tester: ChinaNetworkTester) -> Optional[Dict]:
            """æµ‹è¯•å•ä¸ªIPçš„è¿é€šæ€§"""
            ip = ip_data['ip']
            port = int(ip_data['port'])
            
            print(f"\n{'='*60}")
            print(f"ğŸ” æµ‹è¯• IP: {ip}:{port}")
            print(f"{'='*60}")
            
            # 1. å›½å¤–è¿é€šæ€§æµ‹è¯•
            print(f"    [1/3] ğŸŒ å›½å¤–è¿é€šæ€§...", end=' ')
            overseas_connected, overseas_latency = test_overseas_connectivity(ip, port)
            
            if not overseas_connected:
                print("âŒ ä¸é€š")
                return None
            
            print(f"âœ… é€š ({overseas_latency:.0f}ms)")
            
            # 2. å›½å†…ä¸‰ç½‘çœŸå®æµ‹è¯•
            print(f"    [2/3] å›½å†…ä¸‰ç½‘çœŸå®è¿é€šæ€§æµ‹è¯•:")
            china_result = await tester.test_china_connectivity(session, ip)
            
            if not china_result:
                print(f"        ğŸš« æµ‹è¯•å¤±è´¥ï¼Œè·³è¿‡")
                return None
            
            if not china_result['reliable']:
                print(f"        ğŸš« å›½å†…è¿é€šæ€§ä¸å¯é ï¼ˆä»…{china_result['connected_count']}/3è¿è¥å•†å¯ç”¨ï¼‰")
                return None
            
            # 3. æŸ¥è¯¢åœ°ç†ä½ç½®
            print(f"    [3/3] åœ°ç†ä½ç½®...", end=' ')
            location = await get_ip_location(session, ip, retry=2)
            
            if location == 'Unknown' or '-' not in location:
                print(f"âŒ æ— æ•ˆ")
                return None
            
            print(f"âœ… {location}")
            print(f"    ğŸ‰ é€šè¿‡æ‰€æœ‰æµ‹è¯•ï¼")
            
            return {
                'ip': ip,
                'port': port,
                'location': location,
                'china_result': china_result,
                'overseas_latency': overseas_latency,
            }

        def filter_best_ips_by_location(valid_ips: List[Dict], max_per_location: int = MAX_IPS_PER_LOCATION) -> List[Dict]:
            """æŒ‰åœ°ç†ä½ç½®åˆ†ç»„ï¼Œä¿ç•™æ¯ä¸ªåœ°åŒºå»¶è¿Ÿæœ€ä½çš„IP"""
            by_location = {}
            for ip_info in valid_ips:
                location = ip_info['location']
                if location not in by_location:
                    by_location[location] = []
                by_location[location].append(ip_info)
            
            filtered_ips = []
            for location, ips in by_location.items():
                sorted_ips = sorted(ips, key=lambda x: x['overseas_latency'])
                best_ips = sorted_ips[:max_per_location]
                filtered_ips.extend(best_ips)
                
                if len(ips) > max_per_location:
                    print(f"  ğŸ“ {location}: ä¿ç•™ {max_per_location}/{len(ips)} ä¸ªIP")
                else:
                    print(f"  ğŸ“ {location}: ä¿ç•™å…¨éƒ¨ {len(ips)} ä¸ªIP")
            
            return filtered_ips

        async def main():
            print("=" * 60)
            print("ğŸš€ IP è¿é€šæ€§æµ‹è¯• - æ”¹è¿›ç‰ˆï¼ˆçœŸå®å›½å†…ç½‘ç»œæµ‹è¯•ï¼‰")
            print("=" * 60)
            
            api_urls = load_api_list('api.txt')
            
            if not api_urls:
                print("âŒ æ²¡æœ‰å¯ç”¨çš„ API")
                return
            
            all_ips = []
            seen_ips = set()
            
            async with aiohttp.ClientSession() as session:
                print(f"\nğŸ“¥ ä» {len(api_urls)} ä¸ª API è·å– IP...")
                print("-" * 60)
                
                for idx, api_url in enumerate(api_urls, 1):
                    print(f"[{idx}/{len(api_urls)}] {api_url}")
                    content = await fetch_url(session, api_url)
                    
                    if not content:
                        continue
                    
                    count_before = len(all_ips)
                    for line in content.split('\n'):
                        ip_data = parse_ip_line(line)
                        if ip_data and ip_data['ip'] not in seen_ips:
                            seen_ips.add(ip_data['ip'])
                            all_ips.append(ip_data)
                    
                    new_ips = len(all_ips) - count_before
                    print(f"  {'âœ…' if new_ips > 0 else 'âš ï¸'} æ–°å¢ {new_ips} ä¸ªIP")
                
                print("-" * 60)
                print(f"âœ… å…±æ”¶é›† {len(all_ips)} ä¸ªå”¯ä¸€IP")
                
                if len(all_ips) == 0:
                    with open('ip.txt', 'w', encoding='utf-8') as f:
                        f.write(f"# æµ‹è¯•æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                        f.write("# æœªæ”¶é›†åˆ°ä»»ä½• IP æ•°æ®\n")
                    return
                
                print("\nğŸ”„ å¼€å§‹è¿é€šæ€§æµ‹è¯•...")
                print("=" * 60)
                print("âœ“ å›½å¤–: GitHub ActionsèŠ‚ç‚¹")
                print("âœ“ å›½å†…: IPCheck + ç«™é•¿å·¥å…·ï¼ˆçœŸå®ç½‘ç»œæµ‹è¯•ï¼‰")
                print("âœ“ ä¸‰ç½‘: ä¸­å›½ç”µä¿¡ | ä¸­å›½è”é€š | ä¸­å›½ç§»åŠ¨")
                print(f"âœ“ ä¼˜é€‰: æ¯åœ°åŒºæœ€å¤šä¿ç•™{MAX_IPS_PER_LOCATION}ä¸ª")
                print("=" * 60)
                
                tester = ChinaNetworkTester()
                valid_ips = []
                
                for i in range(0, len(all_ips), BATCH_SIZE):
                    batch = all_ips[i:i+BATCH_SIZE]
                    batch_tasks = [test_ip_connectivity(ip_data, session, tester) for ip_data in batch]
                    results = await asyncio.gather(*batch_tasks)
                    valid_ips.extend([r for r in results if r is not None])
                    
                    progress = min(i + BATCH_SIZE, len(all_ips))
                    print(f"\n{'='*60}")
                    print(f"ğŸ“Š è¿›åº¦: {progress}/{len(all_ips)} ({progress*100//len(all_ips)}%) | é€šè¿‡: {len(valid_ips)}")
                    print(f"{'='*60}")
                    
                    await asyncio.sleep(TEST_DELAY)
            
            print("\n" + "=" * 60)
            print(f"âœ… æµ‹è¯•å®Œæˆ")
            print(f"ğŸ“Š æ€»æ•°: {len(all_ips)} | é€šè¿‡: {len(valid_ips)} | é€šè¿‡ç‡: {len(valid_ips)*100//len(all_ips) if all_ips else 0}%")
            print("=" * 60)
            
            if valid_ips:
                print(f"\nğŸ¯ æŒ‰åœ°åŒºä¼˜é€‰IP...")
                print("-" * 60)
                filtered_ips = filter_best_ips_by_location(valid_ips, MAX_IPS_PER_LOCATION)
                print("-" * 60)
                print(f"âœ… æœ€ç»ˆ: {len(filtered_ips)} ä¸ªIP")
            else:
                filtered_ips = []
            
            # å†™å…¥æ–‡ä»¶
            with open('ip.txt', 'w', encoding='utf-8') as f:
                f.write(f"# IP è¿é€šæ€§æµ‹è¯•ç»“æœï¼ˆæ”¹è¿›ç‰ˆ - çœŸå®å›½å†…ç½‘ç»œæµ‹è¯•ï¼‰\n")
                f.write(f"# æµ‹è¯•æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"# æ€»æµ‹è¯•: {len(all_ips)} | é€šè¿‡: {len(valid_ips)} | ä¼˜é€‰: {len(filtered_ips)}\n")
                f.write(f"# é€šè¿‡ç‡: {len(valid_ips)*100//len(all_ips) if all_ips else 0}%\n")
                f.write(f"# å›½å¤–æµ‹è¯•: GitHub Actions âœ“\n")
                f.write(f"# å›½å†…æµ‹è¯•: IPCheck API âœ“ | ç«™é•¿å·¥å…· âœ“\n")
                f.write(f"# ä¸‰ç½‘è¦æ±‚: è‡³å°‘2/3è¿è¥å•†å¯ç”¨\n")
                f.write(f"# ä¼˜é€‰ç­–ç•¥: æ¯åœ°åŒºæœ€å¤š{MAX_IPS_PER_LOCATION}ä¸ªï¼ˆæŒ‰å»¶è¿Ÿæ’åºï¼‰\n")
                f.write(f"# æ ¼å¼: IP:ç«¯å£#å›½å®¶-åœ°åŒº\n")
                f.write("#" + "=" * 58 + "\n\n")
                
                if filtered_ips:
                    by_location = {}
                    for ip_info in filtered_ips:
                        location = ip_info['location']
                        if location not in by_location:
                            by_location[location] = []
                        by_location[location].append(ip_info)
                    
                    sorted_locations = sorted(by_location.keys())
                    
                    for location in sorted_locations:
                        ips = by_location[location]
                        f.write(f"# {location} ({len(ips)}ä¸ª)\n")
                        
                        sorted_ips = sorted(ips, key=lambda x: x['overseas_latency'])
                        
                        for ip_info in sorted_ips:
                            line = f"{ip_info['ip']}:{ip_info['port']}#{ip_info['location']}"
                            f.write(f"{line}\n")
                        f.write("\n")
                    
                    print(f"\nğŸ’¾ ç»“æœå·²ä¿å­˜åˆ° ip.txt")
                    
                    # ç»Ÿè®¡
                    print("\nğŸ“Š ç»Ÿè®¡ä¿¡æ¯:")
                    country_stats = {}
                    for location, ips in by_location.items():
                        country = location.split('-')[0]
                        if country not in country_stats:
                            country_stats[country] = 0
                        country_stats[country] += len(ips)
                    
                    for country, count in sorted(country_stats.items(), key=lambda x: x[1], reverse=True):
                        print(f"  ğŸŒ {country}: {count} ä¸ª")
                else:
                    f.write("# æœªæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„ IP\n")
                    print("\nâš ï¸ æ²¡æœ‰æ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„IP")

        if __name__ == '__main__':
            asyncio.run(main())
        EOF

    - name: Run IP connectivity test (Improved)
      run: |
        python test_ip_improved.py

    - name: Check if ip.txt exists and has valid data
      id: check_file
      run: |
        if [ -f ip.txt ]; then
          valid_lines=$(grep -v '^#' ip.txt | grep -E '^\s*[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' | wc -l)
          
          if [ "$valid_lines" -gt 0 ]; then
            echo "file_exists=true" >> $GITHUB_OUTPUT
            echo "âœ… ip.txt å·²ç”Ÿæˆï¼ŒåŒ…å« $valid_lines ä¸ªæœ‰æ•ˆIP"
            echo "ip_count=$valid_lines" >> $GITHUB_OUTPUT
          else
            echo "file_exists=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ ip.txt å·²ç”Ÿæˆï¼Œä½†æ— æœ‰æ•ˆIP"
            echo "ip_count=0" >> $GITHUB_OUTPUT
          fi
          
          echo "ğŸ“„ æ–‡ä»¶é¢„è§ˆ:"
          head -n 30 ip.txt
        else
          echo "file_exists=false" >> $GITHUB_OUTPUT
          echo "ip_count=0" >> $GITHUB_OUTPUT
          echo "âŒ ip.txt æœªç”Ÿæˆ"
        fi

    - name: Create Release
      if: steps.check_file.outputs.file_exists == 'true'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ github.run_number }}-${{ github.run_id }}
        name: IP List v${{ github.run_number }} - ${{ steps.check_file.outputs.ip_count }} IPs (çœŸå®å›½å†…ä¸‰ç½‘æµ‹è¯•)
        body: |
          ## ğŸ“‹ IP è¿é€šæ€§æµ‹è¯•ç»“æœï¼ˆæ”¹è¿›ç‰ˆï¼‰
          
          **æµ‹è¯•æ—¶é—´:** `${{ github.event.repository.updated_at }}`  
          **è¿è¡Œç¼–å·:** #${{ github.run_number }}  
          **ä¼˜é€‰ IP:** ${{ steps.check_file.outputs.ip_count }} ä¸ª
          
          ### ğŸ¯ æµ‹è¯•æ–¹æ³•ï¼ˆçœŸå®å›½å†…ç½‘ç»œæµ‹è¯•ï¼‰
          
          #### âœ… å›½å¤–æµ‹è¯•
          - é€šè¿‡ GitHub Actions èŠ‚ç‚¹ç›´æ¥è¿æ¥æµ‹è¯•
          
          #### âœ… å›½å†…æµ‹è¯•ï¼ˆçœŸå®ç½‘ç»œç¯å¢ƒï¼‰
          - **IPCheck API**: ä¸“ä¸šIPè¿é€šæ€§æµ‹è¯•æœåŠ¡ï¼Œæä¾›ä¸‰ç½‘åˆ†æµ‹æ•°æ®
          - **ç«™é•¿å·¥å…·**: å¤šåœ°åŒºå¤šè¿è¥å•†èŠ‚ç‚¹éªŒè¯
          - **åŒæºäº¤å‰éªŒè¯**: åªæœ‰å¤šæ•°æµ‹è¯•æºéƒ½é€šè¿‡æ‰è®¤å®šä¸ºå¯ç”¨
          
          #### ğŸŒ ä¸‰ç½‘è¦æ±‚
          - ä¸­å›½ç”µä¿¡ âœ“
          - ä¸­å›½è”é€š âœ“  
          - ä¸­å›½ç§»åŠ¨ âœ“
          - **è‡³å°‘ 2/3 è¿è¥å•†å¯ç”¨æ‰é€šè¿‡**
          
          #### ğŸ¯ æ™ºèƒ½ä¼˜é€‰ç­–ç•¥
          - æŒ‰åœ°ç†ä½ç½®åˆ†ç»„
          - æ¯ä¸ªåœ°åŒºä¿ç•™å»¶è¿Ÿæœ€ä½çš„æœ€å¤š 5 ä¸ª IP
          - è‡ªåŠ¨è¿‡æ»¤è¢«å¢™ IP
          - åŒ…å«è¯¦ç»†åœ°ç†ä½ç½®ä¿¡æ¯
          
          ### ğŸ“ æ–‡ä»¶æ ¼å¼
          ```
          IP:ç«¯å£#å›½å®¶-åœ°åŒº
          ```
          
          ### ğŸš« GFW æ£€æµ‹æœºåˆ¶
          - å›½å¤–å¯è®¿é—® + å›½å†…ä¸é€š â†’ è‡ªåŠ¨æ’é™¤
          - åªä¿ç•™å›½å†…å¤–å‡å¯è®¿é—®çš„ IP
          - ç¡®ä¿å…¨çƒç”¨æˆ·éƒ½èƒ½æ­£å¸¸ä½¿ç”¨
          
          ### ğŸ“¥ ä½¿ç”¨æ–¹æ³•
          1. ä¸‹è½½ `ip.txt` æ–‡ä»¶
          2. æ¯ä¸ª IP éƒ½å·²é€šè¿‡çœŸå®å›½å†…ç½‘ç»œéªŒè¯
          3. IP æŒ‰å»¶è¿Ÿæ’åºï¼Œä¼˜å…ˆä½¿ç”¨å‰é¢çš„
          4. æ¯å¤©è‡ªåŠ¨æ›´æ–°ï¼ˆåŒ—äº¬æ—¶é—´å‡Œæ™¨ 3 ç‚¹ï¼‰
          
          ### âš™ï¸ æ•°æ®æ¥æº
          IP æ¥æºäº `api.txt` ä¸­é…ç½®çš„ CloudFlare IP ä¼˜é€‰ API
          
          ### ğŸ”„ æ›´æ–°é¢‘ç‡
          - è‡ªåŠ¨: æ¯å¤©åŒ—äº¬æ—¶é—´å‡Œæ™¨ 3 ç‚¹
          - æ‰‹åŠ¨: å¯éšæ—¶åœ¨ Actions é¡µé¢æ‰‹åŠ¨è§¦å‘
          
          ---
          *æ­¤ Release ç”± GitHub Actions è‡ªåŠ¨ç”Ÿæˆ | ä½¿ç”¨çœŸå®å›½å†…ç½‘ç»œæµ‹è¯• ğŸ¤–*
        files: |
          ip.txt
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Keep only latest 5 releases
      if: steps.check_file.outputs.file_exists == 'true'
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const releases = await github.rest.repos.listReleases({
            owner: context.repo.owner,
            repo: context.repo.repo,
            per_page: 100
          });
          
          const sortedReleases = releases.data.sort((a, b) => 
            new Date(b.created_at) - new Date(a.created_at)
          );
          
          console.log(`Found ${sortedReleases.length} releases`);
          
          if (sortedReleases.length > 5) {
            for (let i = 5; i < sortedReleases.length; i++) {
              console.log(`Deleting: ${sortedReleases[i].name}`);
              await github.rest.repos.deleteRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: sortedReleases[i].id
              });
              
              try {
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `tags/${sortedReleases[i].tag_name}`
                });
              } catch (error) {
                console.log(`Tag deletion failed: ${sortedReleases[i].tag_name}`);
              }
            }
            console.log(`âœ… Cleaned ${sortedReleases.length - 5} old releases`);
          } else {
            console.log('âœ… No cleanup needed');
          }
