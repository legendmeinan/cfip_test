name: Test IP Connectivity and Create Release

on:
  schedule:
    - cron: '0 19 * * *'  # 每天北京时间凌晨3点运行 (UTC 19:00 = 北京时间 03:00)
  workflow_dispatch:  # 允许手动触发
  push:
    branches:
      - main
    paths:
      - '.github/workflows/ip-test.yml'
      - 'api.txt'

# 添加必要的权限
permissions:
  contents: write  # 允许创建 Release 和上传文件
  actions: read

jobs:
  test-and-release:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        pip install requests aiohttp asyncio dnspython beautifulsoup4 lxml

    - name: Verify api.txt exists
      run: |
        if [ ! -f api.txt ]; then
          echo "❌ api.txt 文件不存在，正在创建示例文件..."
          cat > api.txt << 'APIEOF'
        # API 列表配置文件
        # 每行一个 API 地址，# 开头的行为注释
        # 
        # CloudFlare IP 优选 API
        https://raw.githubusercontent.com/ymyuuu/IPDB/refs/heads/main/bestproxy.txt
        https://raw.githubusercontent.com/ymyuuu/IPDB/refs/heads/main/bestcf.txt
        https://ip.164746.xyz/ipTop10.html
        https://raw.githubusercontent.com/ZhiXuanWang/cf-speed-dns/refs/heads/main/ipTop10.html
        https://vps789.com/public/sum/cfIpApi
        # https://www.wetest.vip/api/cf2dns/get_cloudflare_ip&type=v4&key=o1zrmHAF
        https://raw.githubusercontent.com/cmliu/WorkerVless2sub/main/addressesapi.txt
        https://addressesapi.090227.xyz/CloudFlareYes
        https://addressesapi.090227.xyz/ip.164746.xyz
        APIEOF
          echo "✅ 已创建示例 api.txt 文件"
        fi
        echo "📋 API 列表内容："
        cat api.txt

    - name: Create test script
      run: |
        cat > test_ip.py << 'EOF'
        import asyncio
        import aiohttp
        import json
        import re
        import socket
        from datetime import datetime
        from typing import List, Dict, Optional, Tuple
        import time
        import os
        import dns.resolver
        from bs4 import BeautifulSoup

        # 每个地区保留的最大IP数量
        MAX_IPS_PER_LOCATION = 5

        # 中国三大运营商的公共 DNS 服务器
        ISP_DNS = {
            '电信': ['114.114.114.114', '114.114.115.115'],
            '联通': ['123.123.123.123', '123.125.81.6'],
            '移动': ['221.179.155.161', '112.4.0.55']
        }

        # 国家代码映射
        COUNTRY_MAPPING = {
            'CN': '中国', 'HK': '香港', 'TW': '台湾', 'JP': '日本', 'KR': '韩国',
            'SG': '新加坡', 'MY': '马来西亚', 'TH': '泰国', 'VN': '越南', 'ID': '印尼',
            'IN': '印度', 'PH': '菲律宾', 'US': '美国', 'CA': '加拿大', 'MX': '墨西哥',
            'DE': '德国', 'GB': '英国', 'FR': '法国', 'IT': '意大利', 'ES': '西班牙',
            'PT': '葡萄牙', 'NL': '荷兰', 'BE': '比利时', 'SE': '瑞典', 'NO': '挪威',
            'AU': '澳大利亚', 'NZ': '新西兰', 'BR': '巴西', 'AR': '阿根廷', 'RU': '俄罗斯',
            'CH': '瑞士', 'AT': '奥地利', 'DK': '丹麦', 'FI': '芬兰', 'IE': '爱尔兰',
            'PL': '波兰', 'CZ': '捷克', 'TR': '土耳其', 'AE': '阿联酋', 'IL': '以色列',
            'ZA': '南非', 'EG': '埃及', 'SA': '沙特', 'UA': '乌克兰', 'GR': '希腊'
        }

        def load_api_list(filename: str = 'api.txt') -> List[str]:
            """从 api.txt 加载 API 列表"""
            api_urls = []
            
            if not os.path.exists(filename):
                print(f"❌ {filename} 文件不存在")
                return api_urls
            
            with open(filename, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        api_urls.append(line)
            
            print(f"✅ 从 {filename} 加载了 {len(api_urls)} 个 API")
            return api_urls

        def is_valid_ip(ip: str) -> bool:
            """验证IP地址格式"""
            parts = ip.split('.')
            if len(parts) != 4:
                return False
            for part in parts:
                try:
                    num = int(part)
                    if num < 0 or num > 255:
                        return False
                    if len(part) > 1 and part[0] == '0':
                        return False
                except ValueError:
                    return False
            return True

        def is_valid_port(port: str) -> bool:
            """验证端口号格式"""
            try:
                num = int(port)
                return 0 < num <= 65535
            except ValueError:
                return False

        def parse_ip_line(line: str) -> Optional[Dict]:
            """解析IP行，支持多种格式"""
            line = line.strip()
            
            if not line or line.startswith(('#', '//', '<!--', 'http')):
                return None
            
            # 模式1: IP:Port#Country
            match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)#(.+)$', line)
            if match:
                ip, port, country = match.groups()
                if is_valid_ip(ip) and is_valid_port(port):
                    return {'ip': ip, 'port': port, 'country': country.strip()}
            
            # 模式2: IP#Country
            match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})#(.+)$', line)
            if match:
                ip, country = match.groups()
                if is_valid_ip(ip):
                    return {'ip': ip, 'port': '443', 'country': country.strip()}
            
            # 模式3: IP:Port
            match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)', line)
            if match:
                ip, port = match.groups()
                if is_valid_ip(ip) and is_valid_port(port):
                    return {'ip': ip, 'port': port, 'country': None}
            
            # 模式4: 单独IP
            match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})$', line)
            if match:
                ip = match.group(1)
                if is_valid_ip(ip):
                    return {'ip': ip, 'port': '443', 'country': None}
            
            return None

        async def fetch_url(session: aiohttp.ClientSession, url: str) -> str:
            """异步获取URL内容"""
            try:
                async with session.get(url, timeout=aiohttp.ClientTimeout(total=30)) as response:
                    if response.status == 200:
                        return await response.text()
                    else:
                        print(f"⚠️  {url} 返回状态码: {response.status}")
            except asyncio.TimeoutError:
                print(f"⏱️  {url} 请求超时")
            except Exception as e:
                print(f"❌ 获取 {url} 失败: {e}")
            return ""

        def normalize_location(location: str) -> str:
            """标准化地理位置格式"""
            if not location or location == 'Unknown':
                return 'Unknown'
            
            location = location.strip()
            location = re.sub(r'\s+', ' ', location)
            
            if '-' not in location and ' ' in location:
                parts = location.split(' ', 1)
                location = '-'.join(parts)
            
            return location

        async def get_ip_location(session: aiohttp.ClientSession, ip: str, retry: int = 2) -> str:
            """获取IP详细地理位置"""
            
            for attempt in range(retry):
                try:
                    async with session.get(f'http://ip-api.com/json/{ip}?lang=zh-CN&fields=status,country,regionName,city,countryCode', 
                                          timeout=aiohttp.ClientTimeout(total=10)) as response:
                        if response.status == 200:
                            data = await response.json()
                            if data.get('status') == 'success':
                                country = data.get('country', '')
                                region_name = data.get('regionName', '')
                                city = data.get('city', '')
                                country_code = data.get('countryCode', '')
                                
                                if country_code and country_code in COUNTRY_MAPPING:
                                    country = COUNTRY_MAPPING[country_code]
                                
                                location_parts = []
                                if country:
                                    location_parts.append(country)
                                
                                if city and city.strip():
                                    location_parts.append(city.strip())
                                elif region_name and region_name.strip():
                                    location_parts.append(region_name.strip())
                                
                                if location_parts:
                                    location = '-'.join(location_parts)
                                    return normalize_location(location)
                except Exception as e:
                    if attempt == retry - 1:
                        print(f"    ⚠️  ip-api.com 查询失败: {e}")
                    await asyncio.sleep(1)
            
            return 'Unknown'

        def measure_latency_via_dns(ip: str, port: int, dns_server: str, timeout: float = 5.0, test_count: int = 3) -> Optional[float]:
            """通过指定DNS服务器测量延迟"""
            latencies = []
            
            for _ in range(test_count):
                try:
                    resolver = dns.resolver.Resolver()
                    resolver.nameservers = [dns_server]
                    resolver.timeout = 2
                    resolver.lifetime = 2
                    
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(timeout)
                    
                    start_time = time.time()
                    result = sock.connect_ex((ip, port))
                    end_time = time.time()
                    
                    sock.close()
                    
                    if result == 0:
                        latency_ms = (end_time - start_time) * 1000
                        latencies.append(latency_ms)
                    
                    time.sleep(0.1)
                    
                except Exception:
                    pass
            
            if latencies:
                avg_latency = sum(latencies) / len(latencies)
                return round(avg_latency, 2)
            else:
                return None

        def test_isp_connectivity_with_latency(ip: str, port: int) -> Dict[str, Dict]:
            """测试IP对三大运营商的连通性和延迟"""
            results = {}
            
            print(f"    测试运营商连通性和延迟:")
            
            for isp_name, dns_servers in ISP_DNS.items():
                best_latency = None
                
                for dns_server in dns_servers:
                    latency = measure_latency_via_dns(ip, port, dns_server, timeout=5.0, test_count=3)
                    
                    if latency is not None:
                        if best_latency is None or latency < best_latency:
                            best_latency = latency
                
                is_connected = best_latency is not None
                results[isp_name] = {
                    'connected': is_connected,
                    'latency': best_latency
                }
                
                status = "✅" if is_connected else "❌"
                latency_str = f"{best_latency:.0f}ms" if best_latency else "不通"
                print(f"      {status} {isp_name}: {latency_str}")
            
            return results

        async def test_china_via_chinaz(session: aiohttp.ClientSession, ip: str) -> bool:
            """通过站长工具测试国内连通性"""
            try:
                url = f"https://ping.chinaz.com/{ip}"
                headers = {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                }
                
                async with session.get(url, headers=headers, timeout=aiohttp.ClientTimeout(total=20)) as response:
                    if response.status != 200:
                        return False
                    
                    html = await response.text()
                    
                    # 简单检查：如果页面包含成功响应的关键词
                    if 'ms' in html and ('响应' in html or 'ping' in html.lower()):
                        # 检查是否有超时过多
                        timeout_count = html.count('超时') + html.count('timeout')
                        success_indicators = html.count('ms')
                        
                        # 如果成功指标多于超时，认为可访问
                        if success_indicators > timeout_count:
                            return True
                    
                    return False
                    
            except Exception as e:
                print(f"      站长工具测试异常: {e}")
                return False

        async def test_china_connectivity(session: aiohttp.ClientSession, ip: str, port: int) -> bool:
            """
            测试国内连通性
            使用公共测试站点进行验证
            """
            print(f"    🇨🇳 国内公共站点测试...")
            
            # 方法1: 站长工具
            result = await test_china_via_chinaz(session, ip)
            
            if result:
                print(f"      ✅ 国内可访问")
                return True
            else:
                print(f"      ❌ 国内不可访问或测试失败")
                return False

        def test_overseas_connectivity(ip: str, port: int, timeout: float = 5.0) -> Tuple[bool, Optional[float]]:
            """测试国外连通性（GitHub Actions环境）"""
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                
                start_time = time.time()
                result = sock.connect_ex((ip, port))
                end_time = time.time()
                
                sock.close()
                
                if result == 0:
                    latency = round((end_time - start_time) * 1000, 2)
                    return True, latency
                else:
                    return False, None
            except Exception:
                return False, None

        async def test_ip_connectivity(ip_data: Dict, session: aiohttp.ClientSession) -> Optional[Dict]:
            """测试单个IP的连通性（国内外双向检测）"""
            ip = ip_data['ip']
            port = int(ip_data['port'])
            
            print(f"\n{'='*60}")
            print(f"🔍 测试 IP: {ip}:{port}")
            print(f"{'='*60}")
            
            # 1. 国外连通性测试
            print(f"  [1/4] 🌍 国外连通性测试...", end=' ')
            overseas_connected, overseas_latency = test_overseas_connectivity(ip, port, timeout=5.0)
            
            if not overseas_connected:
                print("❌ 失败")
                return None
            
            print(f"✅ 成功 ({overseas_latency:.0f}ms)")
            
            # 2. 国内连通性测试（通过公共测试站点）
            print(f"  [2/4] 国内连通性测试:")
            china_accessible = await test_china_connectivity(session, ip, port)
            
            if not china_accessible:
                print(f"      🚫 国内不可访问，疑似被墙，跳过")
                return None
            
            # 3. 三网延迟测试
            print(f"  [3/4] 三网延迟测试:")
            isp_results = test_isp_connectivity_with_latency(ip, port)
            
            # 检查是否全部联通
            all_connected = all(result['connected'] for result in isp_results.values())
            
            if not all_connected:
                failed_isps = [isp for isp, result in isp_results.items() if not result['connected']]
                print(f"      ⚠️  部分运营商不通: {', '.join(failed_isps)}")
                print(f"      ❌ 未通过三网测试，跳过")
                return None
            
            # 计算平均延迟
            latencies = [result['latency'] for result in isp_results.values() if result['latency'] is not None]
            avg_latency = round(sum(latencies) / len(latencies), 2) if latencies else 0
            
            print(f"      ✅ 电信、联通、移动全部联通")
            print(f"      📊 平均延迟: {avg_latency:.0f}ms")
            
            # 4. 查询地理位置
            print(f"  [4/4] 查询地理位置信息...")
            location = await get_ip_location(session, ip, retry=3)
            
            if location == 'Unknown':
                print(f"      ⚠️  无法获取地理位置，跳过")
                return None
            
            print(f"      📍 位置: {location}")
            
            if not location or location == 'Unknown' or '-' not in location:
                print(f"      ❌ 格式异常")
                return None
            
            print(f"  🎉 此IP通过所有测试（国内外均可访问）！")
            
            return {
                'ip': ip,
                'port': port,
                'location': location,
                'isp_results': isp_results,
                'avg_latency': avg_latency,
                'overseas_latency': overseas_latency,
                'china_accessible': True
            }

        def filter_best_ips_by_location(valid_ips: List[Dict], max_per_location: int = MAX_IPS_PER_LOCATION) -> List[Dict]:
            """按地理位置分组，保留每个地区延迟最低的IP"""
            by_location = {}
            for ip_info in valid_ips:
                location = ip_info['location']
                if location not in by_location:
                    by_location[location] = []
                by_location[location].append(ip_info)
            
            filtered_ips = []
            for location, ips in by_location.items():
                sorted_ips = sorted(ips, key=lambda x: x['avg_latency'])
                best_ips = sorted_ips[:max_per_location]
                filtered_ips.extend(best_ips)
                
                if len(ips) > max_per_location:
                    print(f"  📍 {location}: 保留最优 {max_per_location}/{len(ips)} 个IP (延迟: {best_ips[0]['avg_latency']:.0f}ms - {best_ips[-1]['avg_latency']:.0f}ms)")
                else:
                    print(f"  📍 {location}: 保留全部 {len(ips)} 个IP")
            
            return filtered_ips

        async def main():
            print("=" * 60)
            print("🚀 开始测试 IP 连通性（国内外双向检测）")
            print("=" * 60)
            
            api_urls = load_api_list('api.txt')
            
            if not api_urls:
                print("❌ 没有可用的 API，请检查 api.txt 文件")
                return
            
            all_ips = []
            seen_ips = set()
            
            async with aiohttp.ClientSession() as session:
                print(f"\n📥 正在从 {len(api_urls)} 个 API 获取 IP 列表...")
                print("-" * 60)
                
                for idx, api_url in enumerate(api_urls, 1):
                    print(f"[{idx}/{len(api_urls)}] {api_url}")
                    content = await fetch_url(session, api_url)
                    
                    if not content:
                        continue
                    
                    lines = content.split('\n')
                    count_before = len(all_ips)
                    
                    for line in lines:
                        ip_data = parse_ip_line(line)
                        if ip_data and ip_data['ip'] not in seen_ips:
                            seen_ips.add(ip_data['ip'])
                            all_ips.append(ip_data)
                    
                    new_ips = len(all_ips) - count_before
                    if new_ips > 0:
                        print(f"  ✅ 新增 {new_ips} 个 IP")
                    else:
                        print(f"  ⚠️  未获取到新 IP")
                
                print("-" * 60)
                print(f"✅ 共收集到 {len(all_ips)} 个唯一 IP")
                
                if len(all_ips) == 0:
                    print("❌ 没有收集到任何 IP，请检查 API 是否正常")
                    with open('ip.txt', 'w', encoding='utf-8') as f:
                        f.write(f"# 测试时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                        f.write("# 未收集到任何 IP 数据\n")
                    return
                
                print("\n🔄 开始测试连通性（国内外双向检测）...")
                print("=" * 60)
                print("说明: 只保留国内外均可访问且三网全通的IP")
                print(f"策略: 每个地区保留延迟最低的最多 {MAX_IPS_PER_LOCATION} 个IP")
                print("=" * 60)
                
                valid_ips = []
                
                batch_size = 5  # 降低并发，因为要调用公共测试站点
                for i in range(0, len(all_ips), batch_size):
                    batch = all_ips[i:i+batch_size]
                    batch_tasks = [test_ip_connectivity(ip_data, session) for ip_data in batch]
                    results = await asyncio.gather(*batch_tasks)
                    valid_ips.extend([r for r in results if r is not None])
                    
                    progress = min(i + batch_size, len(all_ips))
                    print(f"\n{'='*60}")
                    print(f"📊 进度: {progress}/{len(all_ips)} ({progress*100//len(all_ips)}%) | 国内外均可访问: {len(valid_ips)}")
                    print(f"{'='*60}")
                    
                    await asyncio.sleep(2)  # 延迟，避免公共站点限流
            
            print("\n" + "=" * 60)
            print(f"✅ 测试完成！")
            print(f"📊 总测试数: {len(all_ips)}")
            print(f"✅ 国内外均可访问: {len(valid_ips)}")
            print(f"📈 通过率: {len(valid_ips)*100//len(all_ips) if all_ips else 0}%")
            print("=" * 60)
            
            if valid_ips:
                print(f"\n🎯 开始按地区优选IP (每个地区最多保留{MAX_IPS_PER_LOCATION}个)...")
                print("-" * 60)
                filtered_ips = filter_best_ips_by_location(valid_ips, MAX_IPS_PER_LOCATION)
                print("-" * 60)
                print(f"✅ 优选完成: {len(filtered_ips)}/{len(valid_ips)} 个IP")
            else:
                filtered_ips = []
            
            # 写入文件
            with open('ip.txt', 'w', encoding='utf-8') as f:
                f.write(f"# IP 国内外双向连通性测试结果\n")
                f.write(f"# 测试时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"# 总测试数: {len(all_ips)}\n")
                f.write(f"# 国内外均可访问: {len(valid_ips)}\n")
                f.write(f"# 优选保留: {len(filtered_ips)}\n")
                f.write(f"# 通过率: {len(valid_ips)*100//len(all_ips) if all_ips else 0}%\n")
                f.write(f"# 国外: GitHub Actions节点 ✓\n")
                f.write(f"# 国内: 公共测试站点验证 ✓\n")
                f.write(f"# 运营商: 中国电信 ✓ | 中国联通 ✓ | 中国移动 ✓\n")
                f.write(f"# 优选策略: 每个地区保留延迟最低的最多 {MAX_IPS_PER_LOCATION} 个IP\n")
                f.write(f"# 格式: IP:端口#国家-地区\n")
                f.write("#" + "=" * 58 + "\n\n")
                
                if filtered_ips:
                    by_location = {}
                    for ip_info in filtered_ips:
                        location = ip_info['location']
                        if location not in by_location:
                            by_location[location] = []
                        by_location[location].append(ip_info)
                    
                    sorted_locations = sorted(by_location.keys(), key=lambda x: (
                        x.split('-')[0],
                        x.split('-')[1] if '-' in x and len(x.split('-')) > 1 else ''
                    ))
                    
                    for location in sorted_locations:
                        ips = by_location[location]
                        f.write(f"# {location} ({len(ips)}个)\n")
                        
                        sorted_ips = sorted(ips, key=lambda x: x['avg_latency'])
                        
                        for ip_info in sorted_ips:
                            line = f"{ip_info['ip']}:{ip_info['port']}#{ip_info['location']}"
                            f.write(f"{line}\n")
                        f.write("\n")
                    
                    print(f"\n💾 结果已保存到 ip.txt")
                    
                    # 统计信息
                    print("\n📊 地理位置分布统计:")
                    country_stats = {}
                    for location, ips in by_location.items():
                        country = location.split('-')[0]
                        if country not in country_stats:
                            country_stats[country] = {'count': 0, 'latencies': []}
                        country_stats[country]['count'] += len(ips)
                        for ip in ips:
                            country_stats[country]['latencies'].append(ip['avg_latency'])
                    
                    for country, stats in sorted(country_stats.items(), key=lambda x: x[1]['count'], reverse=True):
                        avg_latency = sum(stats['latencies']) / len(stats['latencies'])
                        print(f"  🌍 {country}: {stats['count']} 个 (平均延迟: {avg_latency:.0f}ms)")
                    
                    all_latencies = [ip['avg_latency'] for ip in filtered_ips]
                    print("\n⏱️  延迟统计:")
                    print(f"  🏆 最低延迟: {min(all_latencies):.0f}ms")
                    print(f"  📊 平均延迟: {sum(all_latencies)/len(all_latencies):.0f}ms")
                    print(f"  📈 最高延迟: {max(all_latencies):.0f}ms")
                    
                else:
                    f.write("# 未找到国内外均可访问的 IP\n")
                    print("\n⚠️  没有找到国内外均可访问的 IP")

        if __name__ == '__main__':
            asyncio.run(main())
        EOF

    - name: Run IP connectivity test
      run: |
        python test_ip.py

    - name: Check if ip.txt exists and has valid data
      id: check_file
      run: |
        if [ -f ip.txt ]; then
          valid_lines=$(grep -v '^#' ip.txt | grep -E '^\s*[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' | wc -l)
          
          if [ "$valid_lines" -gt 0 ]; then
            echo "file_exists=true" >> $GITHUB_OUTPUT
            echo "✅ ip.txt 文件已生成，包含 $valid_lines 个有效 IP"
            echo "ip_count=$valid_lines" >> $GITHUB_OUTPUT
          else
            echo "file_exists=false" >> $GITHUB_OUTPUT
            echo "⚠️  ip.txt 文件已生成，但没有有效的 IP 数据"
            echo "ip_count=0" >> $GITHUB_OUTPUT
          fi
          
          echo "📄 文件内容预览:"
          head -n 30 ip.txt
        else
          echo "file_exists=false" >> $GITHUB_OUTPUT
          echo "ip_count=0" >> $GITHUB_OUTPUT
          echo "❌ ip.txt 文件未生成"
        fi

    - name: Create Release
      if: steps.check_file.outputs.file_exists == 'true'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ github.run_number }}-${{ github.run_id }}
        name: IP List ${{ github.run_number }} - ${{ steps.check_file.outputs.ip_count }} IPs (国内外均可访问)
        body: |
          ## 📋 IP 国内外双向连通性测试结果
          
          **测试时间:** `${{ github.event.repository.updated_at }}`  
          **运行编号:** #${{ github.run_number }}  
          **优选 IP:** ${{ steps.check_file.outputs.ip_count }} 个
          
          ### 📊 测试说明
          - ✅ 所有 IP 均通过国内外双向连通性测试
          - 🌍 **国外节点**: GitHub Actions ✓
          - 🇨🇳 **国内验证**: 公共测试站点 ✓
          - 🌐 **三网测试**: 中国电信 ✓ | 中国联通 ✓ | 中国移动 ✓
          - ⏱️ 基于延迟测试进行智能优选
          - 📍 包含详细地理位置信息（国家-城市/地区）
          - 🎯 **智能优选**: 每个地区保留延迟最低的最多5个IP
          - 📝 格式: `IP:端口#国家-地区`
          - 🔄 每天北京时间凌晨 3 点自动更新
          
          ### 🎯 质量保证
          - **国外可访问**: 通过GitHub Actions节点验证
          - **国内可访问**: 通过公共测试站点验证（站长工具等）
          - **三网全通**: 电信、联通、移动均可连接
          - **延迟优选**: 按地区保留最优IP
          - **自动过滤**: 排除被GFW封锁的IP
          
          ### 🚫 GFW检测
          本测试采用国内外双向检测机制：
          - 如果IP在国外可访问但国内不通 → 自动排除（疑似被墙）
          - 只保留国内外均可访问的IP
          - 确保全球用户都能正常使用
          
          ### 📥 使用方法
          1. 下载 `ip.txt` 文件
          2. 按照格式使用其中的 IP 地址
          3. 每个 IP 都已验证国内外均可连接
          4. IP已按延迟排序，优先使用列表前面的IP
          
          ### ⚙️ API 来源
          IP 数据来自 `api.txt` 文件中配置的 API 接口
          
          ---
          *此 Release 由 GitHub Actions 自动生成 🤖*
        files: |
          ip.txt
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Keep only latest 5 releases
      if: steps.check_file.outputs.file_exists == 'true'
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const releases = await github.rest.repos.listReleases({
            owner: context.repo.owner,
            repo: context.repo.repo,
            per_page: 100
          });
          
          const sortedReleases = releases.data.sort((a, b) => 
            new Date(b.created_at) - new Date(a.created_at)
          );
          
          console.log(`Found ${sortedReleases.length} releases`);
          
          if (sortedReleases.length > 5) {
            for (let i = 5; i < sortedReleases.length; i++) {
              console.log(`Deleting release: ${sortedReleases[i].name} (${sortedReleases[i].tag_name})`);
              await github.rest.repos.deleteRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: sortedReleases[i].id
              });
              
              try {
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `tags/${sortedReleases[i].tag_name}`
                });
                console.log(`Deleted tag: ${sortedReleases[i].tag_name}`);
              } catch (error) {
                console.log(`Could not delete tag: ${sortedReleases[i].tag_name}`);
              }
            }
            console.log(`✅ Cleaned up ${sortedReleases.length - 5} old releases`);
          } else {
            console.log('✅ No cleanup needed');
          }
